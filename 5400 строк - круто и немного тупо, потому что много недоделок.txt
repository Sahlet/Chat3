
















Звіт до модульної роботи
з дисципліни «комп’ютерні мережі»



Виконав: студент гр. 
    ПМ-13-1
    Кривоносов О. Д.
Перевірив: 
    Мащенко Л. В.
 








                                                                 














ЗМІСТ

	
Звіт до модульної роботи	0
ЗМІСТ	1
ПОСТАНОВКА ЗАДАЧІ	2
ТЕОРЕТИЧНА ЧАСТИНА	2
ОПИС ПРОГРАМИ ТА ДАНИХ	6
ТЕСТУВАННЯ	11
СПИСОК ЛІТЕРАТУРИ	16
ДОДАТОК (код програми)	16
Код, що описує базу даних та збереженні процедури	16









?
ПОСТАНОВКА ЗАДАЧІ

Т е м а.  Чат (програма, яка забезпечує передавання текстових повідомлень).
Ц i л ь.  Ознайомитись з API сервера MYSQL, API MYSQL у c++, API WINSOCK у c++, використанням класу сокетів у .NET «System.Net.Sockets», написати обгортку (клас) над API WINSOCK у c++.
Постановка  завдання
Реалізувати чат, який матиме такий архітектурний вигляд:
	інтерфейс ------- сервер менеджер чату ------- сервер бази даних.

Виконаті такі умови:
1.	всі повідомлення між архітектурними вузлами «интерфейс» та «сервер менеджер чату» будуються з двох частин:
	1 – перші два байти кожного повідомлення означають собою кількість байтів, що треба буде прийняти;
2 – саме повідомлення, що складається з тієї кількості байтів, що було зазначено першою частиною повідомлення.
Можна сказати, що ця вимога стосовно сеансового рівня стеку протоколів.
Таким чином кожне повідомлення не може бути представленим більш ніж 2^16 байтами (пакет TCP/IP теж не може бути быльшим).
2.	Всі повідомлення мають зберігатися на сервері бази даних.
3.	Користувач може мати друзів, може подати заявку в друзі, може прийняти заявку в друзі, може переглянути, чи є інший користувач у мережі, може пересвідчитись (не перечитуючи повідомлення, чи були прочитані ім повідомлення від конкретного друга).

ТЕОРЕТИЧНА ЧАСТИНА

Застосування СУБД для роботи з інтегрованими БД виявило особливу важливість проблеми цілісності БД. База даних може використовуватися у випадку, коли її стан відповідає стану предметної області. Ці стани називають цілісними.
Будь-яка база даних придатна до використання тільки тоді, коли її стан відповідає стану предметної області. Такі стани називають цілісними. Очевидно, що при зміні даних БД повинна переходити від одного цілісного стану до іншого. Однак, в процесі оновлення даних можливі ситуації, коли стан цілісності порушується, наприклад:
У банківській системі проводиться переведення грошових коштів з одного рахунку на інший. На мові SQL ця операція описується послідовністю двох команд UPDATE:

UPDATE accounts SET summa=summa-1000 WHERE account="PC_1"
UPDATE accounts SET summa=summa+1000 WHERE account="PC_2"

Як бачимо, після виконання першої команди і до завершення другої команди база даних не знаходиться в цілісному стані, тобто шукана сума списана з першого рахунку, але не зарахована на другий. Якщо в цей момент в системі відбудеться збій, наприклад, виключення електроживлення, то цілісний стан бази даних буде безповоротно втрачено.
Цілісність бази даних може порушуватися і під час обробки однієї команди SQL. Нехай виконується операція збільшення зарплати всіх співробітників фірми на 20%:

                   UPDATE employers SET salary=salary*1.2

При цьому СУБД послідовно обробляє всі записи, що підлягають оновленню, тобто існує часовий інтервал, коли частина записів містить нові значення, а частина – старі.
Щоб уникнути таких ситуацій в СУБД вводиться поняття транзакції. Під транзакцією розуміється неподільна з точки зору впливу на БД послідовність операторів маніпулювання даними (читання, видалення, вставки, модифікації), що приводить до одного з двох можливих результатів: або послідовність виконується, якщо всі оператори правильні, або вся транзакція відкочується, якщо хоча б один оператор не може бути успішно виконаний. Обробка транзакцій гарантує цілісність інформації в базі даних. Таким чином, транзакція переводить базу даних з одного цілісного стану в інший.
Методом контролю за транзакціями є ведення журналу, в якому фіксуються всі зміни, що здійснюються транзакцією в БД. Якщо під час обробки транзакції відбувається збій, транзакція відкочується – з журналу встановлюється стан БД на момент початку транзакції.
У СУБД початок транзакції може задаватися явно, наприклад, командою BEGIN TRANSACTION, або передбачатися неявно, тобто чергова транзакція відкривається автоматично одразу ж після вдалого чи невдалого завершення попередньої. Для завершення транзакції зазвичай використовують команди SQL:
• COMMIT – успішно завершити транзакцію
• ROLLBACK – відкотити транзакцію, тобто повернути БД в стан, в якому вона перебувала на момент початку транзакції.
Стандарт SQL визначає, що транзакція починається з першого SQL-оператора, ініційованого користувачем або міститься в прикладній програмі. Усі наступні SQL-оператори складають тіло транзакції. Транзакція завершується одним з можливих способів:
1.	оператор COMMIT означає успішне завершення транзакції, всі зміни, внесення в базу даних робляться постійними;
2.	оператор ROLLBACK перериває транзакцію і скасовує всі внесені нею зміни;
3.	успішне заверешення програми, яка ініціювала транзакцію, означає успішне завершення транзакції (як використання COMMIT);
4.	помилкове завершення програми перериває транзакцію (як ROLLBACK).

Приклад явно заданої транзакції:
         BEGIN TRANSACTION;              /*Почати транзакцію*/
         DELETE ...;                     /*Зміни*/
         UPDATE ...;                     /*даних*/
         if (знайдена помилка) ROLLBACK;
         else COMMIT;                    /*Завершити транзакцію*/

Прилад неявно заданої транзакції: 
         СOMMIT;                    /*Закінчення попередньої транзакції*/
         DELETE ...;                     /*Зміни*/
         UPDATE ...;                     /*даних*/
         if (знайдена помилка) ROLLBACK;
         else COMMIT;                    /*Завершити транзакцію*/

Описаний механізм транзакцій гарантує забезпечення цілісного стану бази даних тільки в тому випадку, коли всі транзакції виконуються послідовно, тобто в кожну одиницю часу активна тільки одна транзакція. Якщо роботу з даними ведуть одночасно кілька користувачів, такий спосіб організації обробки запитів не приємний, тому що це призведе до збільшення часу реакції системи. У той же час, якщо одночасно виконуються дві транзакції, можуть виникнути такі помилкові ситуації:
• брудне читання (Dirty Read) – транзакція Т1 модифікувала якийсь елемент даних. Після цього інша транзакція Т2 прочитала вміст цього елементу даних до завершення транзакції Т1. Якщо Т1 завершується операцією ROLLBACK, це означає, що транзакція Т2 прочитала неіснуючі дані.
• неповторюване (розмите) читання (Non-repeatable or Fuzzy Read) – транзакція Т1 прочитала вміст елементу даних. Після цього інша транзакція Т2 модифікувала або видалила цей елемент. Якщо Т1 прочитає вміст цього елементу знову, то вона отримає інше значення або виявить, що елемент даних більше не існує.
• Фантом (фіктивні елементи) (Phantom) – транзакція Т1 прочитала вміст декількох елементів даних, які відповідають деякій умові. Після цього Т2 створила елемент даних, який задовольняє цій умові і стала фіксованою. Якщо Т1 повторить читання з цією ж умовою, тоді вона отримає інший набір даних.
Жодна з цих ситуацій не може виникнути при послідовному виконанні транзакцій. Звідси виникло поняття серіалізація – здатність до впорядкування паралельної обробки транзакцій. Тобто почергове (паралельне) виконання заданої множини транзакцій буде вірним, якщо при його виконанні буде отриманий той самий результат, як і при послідовному виконанні тих самих транзакцій.
Такі ситуації виникають тільки тому, що виконання транзакцій Т1 і Т2 не було впорядковано, тобто не було еквівалентно виконанню спочатку транзакції Т1, а потім Т2, або, навпаки, спочатку транзакції Т2, а потім Т1.
Примусове впорядкування транзакцій забезпечується за допомогою механізму блокувань. Суть цього механізму в наступному: якщо для виконання деякої транзакції необхідно, щоб деякий об'єкт бази даних (кортеж, набір кортежів, ставлення, набір відносин, і т.д.) не змінювався непередбачувано і без відома цієї транзакції, такий об'єкт блокується.
Основними видами блокувань є:
•	блокування з взаємним доступом, також має назву S-блокування (від Shared locks) і блокуванням із читання.
•	монопольне блокування (без взаємного доступу), також має назву X-блокування (від eXclusive locks) або блокування із запису. Цей режим використовується при операціях зміни, додавання та видалення об'єктів.


При цьому: 
•	Якщо транзакція накладає на об'єкт X-блокування, то будь-який запит іншої транзакції з блокуванням цього об'єкту буде відкинутий.
•	Якщо транзакція накладає на об'єкт S-блокування, тоді:
o	запит з боку іншої транзакції з X-блокуванням на цей об'єкт буде відкинутий;
o	запит з боку іншої транзакції з S-блокуванням цього об'єкту буде прийнятий. 
Доведено, що серіалізація транзакцій або, інакше, їх ізоляція забезпечується при використанні двофазного протоколу блокувань 2LP – 
Two-Phase Locks, згідно з яким всі блокування, здійснені транзакцією, знімаються тільки при її завершенні. Тобто виконання транзакції розбивається на дві фази: (1) – накопичення блокувань, (2) – звільнення блокувань в результаті фіксації.
Застосування механізму блокування призводить до уповільнення обробки транзакцій, оскільки система змушена очікувати поки звільняться дані, захоплені конкуруючої транзакцією. Вирішити цю проблему можна за рахунок зменшення фрагментів даних, які захоплені транзакцією. Залежно від захоплених об'єктів розрізняють кілька рівнів блокування:
•	блокування усієї бази даних;
•	блокування окремих таблиць;
•	блокування сторінок;
•	блокування записів;
•	блокування окремих полів.
Сучасні СУБД, можуть здійснювати блокування на рівні записів або сторінок.
Мова SQL також надає спосіб непрямого управління швидкістю виконання транзакцій за допомогою зазначення рівня ізоляції транзакції. Під рівнем ізоляції транзакції розуміють можливість виникнення однієї з описаних вище помилкових ситуацій. У стандарті SQL визначено 4 рівня ізоляції:

Таблиця 1 
Рівні ізоляції
Рівень ізоляції	Брудне читання	Розмите читання	Фантом
Незафіксоване читання
(READ UNCOMMITTED)	можливо	можливо	можливо
Зафіксоване читання
(READ COMMITED)	можливо	можливо	можливо
Повторюване читання
(REPEATABLE READ)	можливо	неможливо	можливо
Серіалізація
(SERIALIZABLE)	можливо	неможливо	неможливо
 
Для визначення характеристик транзакції використовується оператор

	SET TRANSACTION <режим доступу>, <рівень ізоляції>

Список рівнів ізоляції наведено в табл. 1. Режим доступу за замовчуванням використовується READ WRITE (читання запис), якщо заданий рівень ізоляції READ UNCOMMITED, то режим доступу повинен бути READ ONLY (тільки читання).
Одним з найбільш суттєвих недоліків методу серіалізації транзакцій на основі механізму блокувань є можливість виникнення глухих кутів (тупиків) (dead locks) між транзакціями. Наприклад, транзакція Т1 наклала монопольне блокування на об'єкт О1 і претендує на доступ до об'єкту О2, який вже монопольно заблокований транзакцією Т2, яка чекає доступу до об'єкта О1. У цьому випадку жодна з транзакцій тривати не може, отже, блокування об'єктів О1 і О2 ніколи не будуть зняті. Природного виходу з такої ситуації не існує, тому тупикові ситуації виявляються і усуваються штучно.



ОПИС ПРОГРАМИ ТА ДАНИХ

Програма має такий архітектурний вигляд:
	інтерфейс ------- сервер менеджер чату ------- сервер бази даннх.

Будемо описувати від серверів до інтерфейсу.

Сервер бази данних:
Є база даних my_chat.
Основою бази даних е таблиці:
1.	my_chat.users
2.	my_chat.r_c_m
Коментарі
« 
-- список ссылок на сообщения (такая таблица нужна, чтоб знать, каки сообщения из списка сообщений доступны конкретному пользователю
-- эта таблица не создается для приватных переписок). имя такой таблицы для каждого пользователя задается так:
-- CONCAT(id этого рользователя, '_', имя таблицы с сообщениями)
»
3.	my_chat.private_chats
Коментарі
«
-- список личных переписок
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('p', some id from users)
»
4.	my_chat.conferences
Коментарі
«
-- список конференций
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('с', some id from users)
»
5.	my_chat.requests
Коментарі
«
-- список запросов в друзья
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('r', some id from users)
»
6.	my_chat.chat_m_g_d
Коментарі
«
-- участники чата
-- поле acs принимает 4 значения (NULL, '', 'g', 'r')
-- NULL	- доступ закрыт
-- ''	- обычный пользователь
-- 'g' 	- пользователь, который может добавлять в чат других пользователей и менять имя чата
-- 'r' 	- один пользователь, который назначать предыдущие уравни доступа всем пользователям и может добавлять в чат других пользователей
-- имя такой таблицы для каждого чата задается так:
-- CONCAT('part', имя таблиции сообщений, соответствующее этому списку участников переписки)
»
7.	my_chat.chat_m_u_d
Коментарі
«
-- chat_members_user_default
»
8.	my_chat.chat_name
Коментарі
«
-- хранит имя чата (всего одна строка)
-- имя такой таблицы для каждого чата задается так:
-- CONCAT('name', имя таблиции сообщений)
»
9.	my_chat.messages
Коментарі
«
-- сообщения
-- имя такой таблицы для каждого чата задается, как индекс пользователя, что создал этот чат, и номер созданного им чата, что хранится в my_chat.users.n_created_chats
»
	Далі маються такі збережені процедури
1.	AUT відповідає за авторизацію користувача чату
2.	GET_USER_ID
3.	ADDUSER
4.	GET_FRIEND_ID
5.	GET_FRIEND_LOG
6.	SEND_P_M відіслати приватне повідомлення
7.	SEND_C_M відіслати повідомлення у конференцію
8.	SEND_REQUEST відіслати запит на прийняття в друзі
9.	ACCEPT_REQUEST прийняти запит на прийняття в друзі
10.	CREATE_CHAT
11.	IS_FRIEND_IN_CHAT
12.	ADD_PART додати користувача у конференцію
13.	SET_ACCESS задати рівень доступу
14.	ONLINE
15.	GNM_PART_F_CHAT взяти M членів конференції починаючи з N-го
16.	GNM_REQUESTS
17.	GNM_MESSAGES_P
18.	GNM_MESSAGES_С
19.	GNM_CHATS
20.	GET_LAST_USER_TICK
21.	GET_USER_DATA
22.	GNM_USERS
23.	GET_UNREAD_LAST_TICK;

Сервер менеджер чату:
Є реалізація обгортки для API WINSOCK яку можна знайти в додатку.
Є основні команди:
1.	"check"
Коментарі
«
перевірити правильність комбінації логін пароль
»
2.	"smp"
Коментарі
«
надислати приватне повідомлення
»
3.	 "smc"
Коментарі
«
надислати повідомлення до конференції
»
4.	"sr"
Коментарі
«
надіслати заявку в друзі
»
5.	"ar"
6.	"cc"
Коментарі
«
створити переписку
»
7.	"ap"
Коментарі
«
додати користувача
»
8.	"line"
Коментарі
«
сповістити про че, що користувач онлайн
»
9.	"sa"
Коментарі
«
задати рівень доступу
»
10.	"gud"
Коментарі
«
взяти данні користувача
»
11.	"glut"
Коментарі
«
взяти останній тік користувача
»
12.	"gnmp"
Коментарі
«
geter_n_m_partners_from
»
13.	"gnmr"
Коментарі
«
geter_n_m_requests
»
14.	"gnmmp"
Коментарі
«
geter_n_m_messages_p
»
15.	"gnmc"
Коментарі
«
geter_n_m_messages_c
»
16.	"gnmf"
Коментарі
«
geter_n_m_friens
»
17.	"gnmco"
Коментарі
«
geter_n_m_confs
»
18.	"gnmu"
Коментарі
«
geter_n_m_users
»
19.	"gful"
Коментарі
«
geter_freand_unread_last_tick
»
20.	"gcul"
Коментарі
«
geter_conf_unread_last_tick
»
21.	"gfid"
Коментарі
«
get_friend_id
»

Інтерфейс:
Є такі класи:
1.	Button_more – відповідає за кнопку, що означає «завантажити більше»
2.	Central – відповідає за всі основні процеси інтерфейсу
3.	Conference – відповідає за контрол, що для користувача є інтерфейсом до конференції.
4.	Conference_fields – відповідає за управління даними стосовно конкретної конфереції.
5.	Form1 – основна форма.
6.	Form2 – форма авторизації та регистрації
7.	Form3 – форма інформації 
8.	ItemList_with_Button_more – контрол, для колекціонування інших контролів; вміщає у себе контрол Button_more.
9.	Menager_for_conference – контрол, що є комплексом контролів для керування.
10.	Message – контрол повідомлення
11.	User – відповідає за контрол, що для користувача є інтерфейсом до конференції.
12.	User_fields – відповідає за управління даними стосовно конкретної конфереції.
13.	Waiter – клас для управління чергою запитів.


ТЕСТУВАННЯ
 
(Рис.1) початок роботи.

 
(Рис.2) користувач зареєструвався під логіном «1»

 
(Рис.3) користувач авторизувався

 
(Рис.4) користувач перейшов до пошуку друзів і хоче собі додати себе у друзі.

 
(Рис.5) користувач послав собі заявку в друзі, і тепер хоче прийняти цю заявку.


 
(Рис.6) користувач прийняв заявку і тепер хоте перейти до переписки.

 
(Рис.7) перейшовши до чату, користувач хоче надіслати собі повідомлення «Привет, ольлзователь 1.»

 
(Рис.8) користувач відправив собі повідомлення і хоче відповісти собі «Ну здравствуй, ольлзователь 1.»

 
(Рис.9)




СПИСОК ЛІТЕРАТУРИ

1.	API MYSQL C++
2.	«MYSQL_Кузнецов М.В., Симдянов И.В. - MySQL 5 (в подлиннике) – 2010»
3.	«У. Р. Стивенс - UNIX. Разработка сетевых приложений, 3-е изд. - 2007»

ДОДАТОК (код програми)

Код, що описує базу даних та збереженні процедури

drop database my_chat;
create database if not exists my_chat;
USE my_chat;
-- comment
#comment
/*comment*/

-- --------------------------------------------------------------------------------------
create table if not exists my_chat.users(
	id SERIAL PRIMARY KEY,				-- SERIAL = BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE
	log VARCHAR(40) NOT NULL UNIQUE, -- UNIQUE - не повторяестя значение этого поля в каждой строке
	pass VARCHAR(40) NOT NULL,
	status VARCHAR(255) NOT NULL DEFAULT '', -- статус
	last_tick TIMESTAMP NOT NULL,	-- если не задать значение, то в переменной будет храниться время изменения (добавления) записи в диапазоне от «1970-01-01 00:00:00» до некоторой даты в 2038 г, ДЛЯ ОБНОВЛЕНИЯ ВРЕМЕНИ ИСПОЛЬЗУЙ ФУНКЦИЮ NOW() или CURRENT_TIMESTAMP //insert into dt1 values(now());
	unread_private_chats BOOL NOT NULL DEFAULT FALSE, -- пользоваетль проверяет, есть ли что-то непрочитанное (значение меняется автоматически)
	unread_chats BOOL NOT NULL DEFAULT FALSE,
	request BOOL NOT NULL DEFAULT FALSE,
	n_unread_private_chats BIGINT UNSIGNED NOT NULL DEFAULT 0, -- количество непросмотренных записей
	n_unread_chats BIGINT UNSIGNED NOT NULL DEFAULT 0,
	n_request BIGINT UNSIGNED NOT NULL DEFAULT 0,
	n_created_chats BIGINT UNSIGNED NOT NULL DEFAULT 0, -- количество созданых чатов.
	-- name VARCHAR(20),
	INDEX(log)
	-- ,INDEX(name)
)ENGINE InnoDB CHARACTER SET utf8;
-- --------------------------------------------------------------------------------------

-- --------------------------------------------------------------------------------------
-- список ссылок на сообщения (такая таблица нужна, чтоб знать, каки сообщения из списка сообщений доступны конкретному пользователю. эта таблица не создается для приватных переписок)
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT(id этого рользователя, '_', имя таблицы с сообщениями)
CREATE TABLE if not exists my_chat.r_c_m(-- ref_chats_messages
	id SERIAL PRIMARY KEY,
	id_m BIGINT UNSIGNED NOT NULL -- указывет на сообщение (не надо делать внешний ключ потому, что невозможно подобрать таблицу, по которой этот ключ будет строиться (значения в этом поля будут из таблицы с неизвестным именем))
)ENGINE InnoDB CHARACTER SET utf8;

-- --------------------------------------------------------------------------------------


-- --------------------------------------------------------------------------------------
-- список личных переписок
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('p', some id from users)
CREATE TABLE if not exists my_chat.private_chats(
	id SERIAL PRIMARY KEY,
	name_of_messages_table VARCHAR(64) NOT NULL UNIQUE,
	unread BOOL NOT NULL DEFAULT FALSE,
	last_tick TIMESTAMP NOT NULL -- чтоб сортировать потом по этому полю
)ENGINE InnoDB CHARACTER SET utf8;

-- список конференций
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('с', some id from users)
CREATE TABLE if not exists my_chat.conferences
	LIKE my_chat.private_chats;

-- список запросов в друзья
-- имя такой таблицы для каждого пользователя задается так:
-- CONCAT('r', some id from users)
CREATE TABLE if not exists my_chat.requests(
	user_id BIGINT UNSIGNED NOT NULL UNIQUE,
	message TEXT NOT NULL,
	last_tick TIMESTAMP NOT NULL,
	FOREIGN KEY(user_id) REFERENCES my_chat.users (id)
	ON UPDATE CASCADE
	ON DELETE RESTRICT
)ENGINE InnoDB CHARACTER SET utf8;
-- --------------------------------------------------------------------------------------





-- --------------------------------------------------------------------------------------
-- участники чата
-- поле acs принимает 4 значения (NULL, '', 'g', 'r')
-- NULL	- доступ закрыт
-- ''	- обычный пользователь
-- 'g' 	- пользователь, который может добавлять в чат других пользователей и менять имя чата
-- 'r' 	- один пользователь, который назначать предыдущие уравни доступа всем пользователям и может добавлять в чат других пользователей
-- имя такой таблицы для каждого чата задается так:
-- CONCAT('part', имя таблиции сообщений, соответствующее этому списку участников переписки)
CREATE TABLE if not exists my_chat.chat_m_g_d( -- chat_members_granting_default
	user_id BIGINT UNSIGNED NOT NULL UNIQUE,
	acs ENUM('g','r','') DEFAULT 'g', -- access
	FOREIGN KEY(user_id) REFERENCES my_chat.users (id) ON UPDATE CASCADE ON DELETE RESTRICT
)ENGINE InnoDB CHARACTER SET utf8;
CREATE TABLE if not exists my_chat.chat_m_u_d -- chat_members_user_default
	LIKE my_chat.chat_m_g_d;
ALTER TABLE my_chat.chat_m_u_d ALTER acs SET DEFAULT '';

-- хранит имя чата (всего одна строка)
-- имя такой таблицы для каждого чата задается так:
-- CONCAT('name', имя таблиции сообщений)
CREATE TABLE if not exists my_chat.chat_name(
	name VARCHAR(64) NOT NULL
)ENGINE InnoDB CHARACTER SET utf8;

-- сообщения
-- имя такой таблицы для каждого чата задается, как индекс пользователя, что создал этот чат, и номер созданного им чата, что хранится в my_chat.users.n_created_chats
create table if not exists my_chat.messages(
	id SERIAL PRIMARY KEY,
	user_id BIGINT UNSIGNED, -- если в этом поле будет NULL - это сообщение от сервера (например сообщение о том, что кто-то из пользователей добавил в чат еще одного пользователя)
	message TEXT NOT NULL,
	last_tick TIMESTAMP NOT NULL,
	FOREIGN KEY(user_id) REFERENCES my_chat.users (id) ON UPDATE CASCADE ON DELETE RESTRICT
);
-- --------------------------------------------------------------------------------------



-- --------------------------------------------------------------------------------------
drop user chat;

CREATE USER chat
	IDENTIFIED BY 'chat';

GRANT ALL ON my_chat.* TO 'chat';

/*
show grants for chat_server;

тут я хотел запретить пользоваетлю chat_server смотреть на пароли и удалять строки в my_chat.users,
но пишет, что не было назначено GRANT для (SELECT(pass) ON my_chat.users) и (DELETE ON my_chat.users) и пожтому отменять нечего...
REVOKE SELECT(pass)
	ON my_chat.users
	FROM 'chat_server';


REVOKE DELETE
	ON my_chat.users
	FROM chat_server;
*/
-- --------------------------------------------------------------------------------------




-- --------------------------------------------------------------------------------------
DELIMITER //

DROP PROCEDURE IF EXISTS GNMF;
CREATE PROCEDURE GNMF(n BIGINT UNSIGNED, m BIGINT UNSIGNED, tabl VARCHAR(64)) -- Get N M From (взять m начиная с n из таблици где есть поле id)
BEGIN
	START TRANSACTION;
		SET @var = CONCAT('SELECT id FROM ', tabl, ' ORDER BY id DESC LIMIT ', n, ', ', m); -- LIMIT <номер строки выборки с которого начинать, количество строк>;
		PREPARE query FROM @var; -- формировка запроса query
		EXECUTE query; -- выполнение запроса query
	COMMIT;
END//

DROP PROCEDURE IF EXISTS AUT;
CREATE PROCEDURE AUT(login VARCHAR(40), password VARCHAR(40)) -- authorize
BEGIN
	START TRANSACTION;
		SELECT id FROM my_chat.users WHERE log = login AND pass = password;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GET_USER_ID;
CREATE PROCEDURE GET_USER_ID(login VARCHAR(40))
BEGIN
	START TRANSACTION;
		SELECT id FROM my_chat.users WHERE log = login;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS ADDUSER;
CREATE PROCEDURE ADDUSER(login VARCHAR(40), password VARCHAR(40))
BEGIN
	START TRANSACTION;
		insert into my_chat.users (log, pass) values(login, password);

		SET @var := CONCAT('CREATE TABLE if not exists my_chat.p', (SELECT @id_ := id FROM my_chat.users WHERE log = login), ' LIKE my_chat.private_chats');
		PREPARE query FROM @var; EXECUTE query;

		SET @var := CONCAT('CREATE TABLE if not exists my_chat.c', @id_, ' LIKE my_chat.conferences');
		PREPARE query FROM @var; EXECUTE query;

		SET @var := CONCAT('CREATE TABLE if not exists my_chat.r', @id_, ' LIKE my_chat.requests');
		PREPARE query FROM @var; EXECUTE query;
	COMMIT;
END//


DROP PROCEDURE IF EXISTS GET_FRIEND_ID;
CREATE PROCEDURE GET_FRIEND_ID(login VARCHAR(40))
BEGIN
		SET @user_id := (SELECT id FROM my_chat.users WHERE log = login);
		IF (@user_id > 0) THEN
			START TRANSACTION;
			SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT LALKA.id, LALKA.name_of_messages_table FROM my_chat.p', @userID, ' AS LALKA');
			PREPARE query FROM @var; EXECUTE query;
			ALTER TABLE addressees ADD COLUMN num SERIAL;
			ALTER TABLE addressees ADD INDEX (num);
			
			SET @i := 1;
			SET @max_ := (SELECT MAX(num) FROM addressees);
			SET @res := 0;
			IF (@user_id = @userID) THEN
				WHILE (@i <= @max_ AND @res = 0) DO
					SET @var := CONCAT('SET @res := (SELECT id FROM addressees WHERE num = @i AND (1 = (SELECT COUNT(user_id) FROM my_chat.part', (SELECT name_of_messages_table FROM addressees WHERE num = @i), ')))');
					PREPARE query FROM @var; EXECUTE query;
					IF (@res > 0) THEN
						SET @tmp := 0;
					ELSE
						SET @res := 0;
					END IF;
					SET @i := @i + 1;
				END WHILE;
			ELSE
				WHILE (@i <= @max_ AND @res = 0) DO
					SET @var := CONCAT('SET @res := (SELECT id FROM addressees WHERE num = @i AND (@user_id IN (SELECT user_id FROM my_chat.part', (SELECT name_of_messages_table FROM addressees WHERE num = @i), ')))');
					PREPARE query FROM @var; EXECUTE query;
					IF (@res > 0) THEN
						SET @tmp := 0;
					ELSE
						SET @res := 0;
					END IF;
					SET @i := @i + 1;
				END WHILE;
			END IF;

			ALTER TABLE addressees DROP COLUMN num;
			ALTER TABLE addressees DROP COLUMN name_of_messages_table;

			SELECT @res;

			DROP TABLE addressees;
			COMMIT;
		END IF;
END//

/*
-- переделать
DROP PROCEDURE IF EXISTS GET_FRIEND_ID_FUNC;
CREATE PROCEDURE GET_FRIEND_ID_FUNC(login VARCHAR(40))
BEGIN
	START TRANSACTION;
		-- переделать
		SET @var = CONCAT('SET @res_GET_FRIEND_ID_FUNC = (SELECT id FROM my_chat.p', @userID, ' WHERE (SELECT id FROM my_chat.users WHERE log = ', login,' ) IN (SELECT user_id FROM CONCAT(''part'', name_of_messages_table)))');
		PREPARE query FROM @var; EXECUTE query;
	COMMIT;
END//
*/

DROP PROCEDURE IF EXISTS GET_FRIEND_LOG;
CREATE PROCEDURE GET_FRIEND_LOG(friendID BIGINT UNSIGNED)
BEGIN
	START TRANSACTION;
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.p', @userID,' WHERE id = ', friendID, ')');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SELECT log FROM my_chat.users WHERE id IN (SELECT user_id FROM my_chat.part', @name, ') AND id != @userID');
		PREPARE query FROM @var; EXECUTE query;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS SEND_P_M;
CREATE PROCEDURE SEND_P_M(freindID BIGINT UNSIGNED, message_ TEXT)
BEGIN
	START TRANSACTION;
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.p', @userID, ' WHERE id = ', freindID, ')');
		PREPARE query FROM @var; EXECUTE query;
		IF (@name != 'wwe') THEN -- wwe просто так. важно что name не NULL
			-- отсылаем собщение
			SET @var := CONCAT('insert into my_chat.', @name, ' (user_id, message) values(@userID, ''', message_,''')');
			PREPARE query FROM @var; EXECUTE query;
			-- SET @var := CONCAT('SET @id_m_ := (SELECT MAX(id) FROM my_chat.', @name, ')');
			-- PREPARE query FROM @var; EXECUTE query;
			-- говорим об этом всем участникам
			SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT user_id FROM my_chat.part', @name);
			PREPARE query FROM @var; EXECUTE query;
			ALTER TABLE addressees ADD COLUMN id SERIAL PRIMARY KEY;
			SET @i := 1;
			SET @max_ := (SELECT MAX(id) FROM addressees);
			WHILE @i <= @max_ DO
				SET @id_ := (SELECT user_id FROM addressees WHERE id = @i);
				
				SET @var := CONCAT('SET @unread_ := (SELECT unread FROM my_chat.p', @id_, ' WHERE id = ', freindID, ')');
				PREPARE query FROM @var; EXECUTE query;
				IF (@unread_ = FALSE) THEN
					UPDATE my_chat.users SET unread_private_chats := TRUE, n_unread_private_chats := n_unread_private_chats + 1 WHERE id = @id_;
					SET @var := CONCAT('UPDATE my_chat.p', @id_, ' SET unread := TRUE WHERE id = ', freindID);
					PREPARE query FROM @var; EXECUTE query;
				ELSE
					UPDATE my_chat.users SET unread_private_chats := TRUE WHERE id = @id_;
				END IF;

				SET @i := @i + 1;
			END WHILE;
			DROP TABLE addressees;
		ELSE
			SELECT 1;
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS SEND_C_M;
CREATE PROCEDURE SEND_C_M(chatID BIGINT UNSIGNED, message_ TEXT)
BEGIN
	START TRANSACTION;
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID, ' WHERE id = ', chatID,')');
		PREPARE query FROM @var; EXECUTE query;
		SET @chek := NULL;
		IF (@name != NULL) THEN
			SET @var = CONCAT('SET @chek := (SELECT acs FROM my_chat.part', @name, ' WHERE user_id = @userID)');
			PREPARE query FROM @var; EXECUTE query;
		END IF;
		IF (@chek != 'wwe') THEN -- wwe просто так. важно что chek не NULL
			-- отсылаем собщение
			SET @var := CONCAT('insert into my_chat.', @name, ' (user_id, message) values(@userID, ''', message_,''')');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('SET @id_m_ := (SELECT MAX(id) FROM my_chat.', @name, ')');
			PREPARE query FROM @var; EXECUTE query;
			-- говорим об этом всем участникам
			SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT user_id FROM my_chat.part', @name, ' WHERE acs != NULL');
			PREPARE query FROM @var; EXECUTE query;
			ALTER TABLE addressees ADD COLUMN id SERIAL PRIMARY KEY;
			SET @i := 1;
			SET @max_ := (SELECT MAX(id) FROM addressees);
			WHILE @i <= @max_ DO
				SET @id_ := (SELECT user_id FROM addressees WHERE id = @i);
				-- 
				
				SET @var := CONCAT('SET @unread_ := (SELECT unread FROM my_chat.c', @id_, ' WHERE id = ', chatID, ')');
				PREPARE query FROM @var; EXECUTE query;
				IF (@unread_ = FALSE) THEN
					UPDATE my_chat.users SET unread_chats := TRUE, n_unread_chats := n_unread_chats + 1 WHERE id = @id_;
					SET @var := CONCAT('UPDATE my_chat.c', @id_, ' SET unread = TRUE WHERE id = ', chatID);
					PREPARE query FROM @var; EXECUTE query;
				ELSE
					UPDATE my_chat.users SET unread_chats := TRUE WHERE id = @id_;
				END IF;

				-- 
				SET @var := CONCAT('insert into my_chat.', @id_, '_', @name, ' (id_m) values(@id_m_)');
				PREPARE query FROM @var; EXECUTE query;
				-- 
				SET @i := @i + 1;
			END WHILE;
			DROP TABLE addressees;
		ELSE
			SELECT 1;
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS SEND_REQUEST;
CREATE PROCEDURE SEND_REQUEST(login VARCHAR(40), message_ TEXT)
BEGIN
	START TRANSACTION;
		-- делаем таблицу реальных id друзей
		SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT LALKA.name_of_messages_table FROM my_chat.p', @userID, ' AS LALKA');
		PREPARE query FROM @var; EXECUTE query;
		ALTER TABLE addressees ADD COLUMN num SERIAL;
		ALTER TABLE addressees ADD INDEX (num);
		ALTER TABLE addressees ADD COLUMN user_id BIGINT;
			
		SET @i := 1;
		SET @max_ := (SELECT MAX(num) FROM addressees);
		WHILE @i <= @max_ DO
			SET @tmp_name := (SELECT name_of_messages_table FROM addressees WHERE num = @i);
			SET @var := CONCAT('UPDATE addressees SET user_id := (SELECT user_id FROM my_chat.part', @tmp_name, ' WHERE (user_id != @userID OR (1 = (SELECT COUNT(user_id) FROM my_chat.part', @tmp_name, ')))) WHERE num = @i');
			PREPARE query FROM @var; EXECUTE query;
			SET @i := @i + 1;
		END WHILE;

		ALTER TABLE addressees DROP COLUMN num;
		ALTER TABLE addressees DROP COLUMN name_of_messages_table;
		-- закончили

		-- проверка, что login - не друг
		-- SET @id_ := NULL;
		SET @id_ := (SELECT id FROM my_chat.users WHERE log = login AND id IN (SELECT user_id FROM addressees));
		IF (@id_ > 0) THEN
			SELECT 'NULL';
		ELSE
			SET @id_ := (SELECT id FROM my_chat.users WHERE log = login);
			SET @var := CONCAT('SET @chek := (SELECT user_id FROM my_chat.r', @id_, ' WHERE user_id = @userID)');
			PREPARE query FROM @var; EXECUTE query;
			IF (@chek > 0) THEN
				SET @var := CONCAT('UPDATE my_chat.r', @id_, ' SET message = ''', message_, ''' WHERE user_id = @userID');
			ELSE
				SET @var := CONCAT('insert into my_chat.r', @id_, ' (user_id, message) values(@userID,''', message_, ''')');
				UPDATE my_chat.users SET n_request := n_request + 1 WHERE id = @id_;
			END IF;
			PREPARE query FROM @var; EXECUTE query;
			UPDATE my_chat.users SET request := TRUE WHERE id = @id_;
		END IF;
		DROP TABLE addressees;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS ACCEPT_REQUEST;
CREATE PROCEDURE ACCEPT_REQUEST(login VARCHAR(40))
BEGIN
	START TRANSACTION;
		SET @var = CONCAT('SET @requesterID := (SELECT user_id FROM my_chat.r', @userID, ' WHERE user_id = (SELECT id FROM my_chat.users WHERE log = ''', login, '''))');
		PREPARE query FROM @var; EXECUTE query;
		IF(@requesterID > 0) THEN
			IF(@userID < @requesterID) THEN
				SET @name = CONCAT(@userID, @requesterID);
			ELSE
				SET @name = CONCAT(@requesterID, @userID);
			END IF;

			SET @var := CONCAT('CREATE TABLE if not exists my_chat.', @name,' LIKE my_chat.messages');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('CREATE TABLE if not exists my_chat.part', @name,' LIKE my_chat.chat_m_u_d');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('insert into my_chat.p', @userID, ' (name_of_messages_table) values(@name)');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('insert into my_chat.part', @name, ' (user_id) values(@userID)');
			PREPARE query FROM @var; EXECUTE query;

			IF(@userID != @requesterID) THEN
				SET @var := CONCAT('insert into my_chat.p', @requesterID, ' (name_of_messages_table) values(@name)');
				PREPARE query FROM @var; EXECUTE query;
				SET @var := CONCAT('insert into my_chat.part', @name, ' (user_id) values(@requesterID)');
				PREPARE query FROM @var; EXECUTE query;
			END IF;

			SET @var := CONCAT('DELETE FROM my_chat.r', @userID, ' WHERE user_id = @requesterID');
			PREPARE query FROM @var; EXECUTE query;
			UPDATE my_chat.users SET n_request := n_request - 1 WHERE id = @userID;

		ELSE
			SELECT CONCAT('you have no requester with login: '' ', login, ' ''.');
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS CREATE_CHAT;
CREATE PROCEDURE CREATE_CHAT(name_of_chat VARCHAR(60), def_user ENUM('g', 'u'))
BEGIN
	START TRANSACTION;
		IF(def_user = 'g' OR def_user = 'u') THEN
			UPDATE my_chat.users SET n_created_chats := (SELECT @n_chat := n_created_chats + 1) WHERE id = @userID;

			SET @name := CONCAT(@userID, '_', @n_chat);
			
			SET @var := CONCAT('CREATE TABLE my_chat.', @name,' LIKE my_chat.messages');
			PREPARE query FROM @var; EXECUTE query;

			SET @var := CONCAT('CREATE TABLE my_chat.part', @name,' LIKE my_chat.chat_m_', def_user, '_d');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('insert into my_chat.part', @name, ' (user_id, acs) values(@userID, ''r'')');
			PREPARE query FROM @var; EXECUTE query;

			SET @var := CONCAT('CREATE TABLE my_chat.name', @name,' LIKE my_chat.chat_name');
			PREPARE query FROM @var; EXECUTE query;
			SET @var := CONCAT('insert into my_chat.name', @name, ' (name) values(name_of_chat)');
			PREPARE query FROM @var; EXECUTE query;

			SET @var := CONCAT('insert into my_chat.с', @userID, ' (name_of_messages_table) values(@name)');
			PREPARE query FROM @var; EXECUTE query;

			SET @var := CONCAT('CREATE TABLE my_chat.', @userID, '_', @name,' LIKE my_chat.r_c_m');
			PREPARE query FROM @var; EXECUTE query;
		ELSE
			SELECT CONCAT('wrong second parameter ', def_user);
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS IS_FRIEND_IN_CHAT;
CREATE PROCEDURE IS_FRIEND_IN_CHAT(friendID BIGINT UNSIGNED, chatID BIGINT UNSIGNED)
BEGIN
	START TRANSACTION;
		-- берем реальное id друга
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.p', @userID,' WHERE id = friendID)');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SET @frienduserID := (SELECT id FROM my_chat.users WHERE id IN (SELECT user_id FROM my_chat.part', @name, '))');
		PREPARE query FROM @var; EXECUTE query;
		-- проверяем есть ли он в данном чате
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID,' WHERE id = chatID)');
		PREPARE query FROM @var; EXECUTE query;
		-- вернет непусто, если есть
		SET @var = CONCAT('SELECT 1 FROM my_chat.part', @name, ' WHERE user_id = @frienduserID');
		PREPARE query FROM @var; EXECUTE query;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS ADD_PART;
CREATE PROCEDURE ADD_PART(friendID BIGINT UNSIGNED, chatID BIGINT UNSIGNED)
BEGIN
	START TRANSACTION;
		-- берем реальное id друга
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.p', @userID,' WHERE id = friendID)');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SET @frienduserID := (SELECT id FROM my_chat.users WHERE id IN (SELECT user_id FROM part', @name, '))');
		PREPARE query FROM @var; EXECUTE query;
		-- проверяем, может ли userID добавлять друзей
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID,' WHERE id = chatID)');
		PREPARE query FROM @var; EXECUTE query;
		SET @chek := NULL;
		SET @var = CONCAT('SET @chek := (SELECT 1 FROM my_chat.part', @name, ' WHERE user_id = @userID AND acs IN (''g'',''r''))');
		PREPARE query FROM @var; EXECUTE query;
		IF(@chek != NULL) THEN
			-- добавляем пользователя в чат
			SET @var := CONCAT('insert into my_chat.part', @name, ' (user_id) values(@frienduserID)');
			PREPARE query FROM @var; EXECUTE query;
			-- создаем список ссылок на сообщения в списке сообщений для @frienduserID
			SET @var := CONCAT('CREATE TABLE my_chat.', @frienduserID, '_', @name,' LIKE my_chat.r_c_m');
			PREPARE query FROM @var; EXECUTE query;
		ELSE
			SELECT 1;
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS SET_ACCESS;
CREATE PROCEDURE SET_ACCESS(login VARCHAR(40), chatID BIGINT UNSIGNED, acs_ ENUM('g','u'))
BEGIN
	START TRANSACTION;
		SET @_acs_ := acs_;
		IF (@_acs_ = 'u') THEN SET @_acs_ := ''; END IF;

		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID,' WHERE id = chatID)');
		PREPARE query FROM @var; EXECUTE query;

		SET @chek := NULL;
		SET @var = CONCAT('SET @chek := (SELECT 1 FROM my_chat.part', @name, ' WHERE user_id = @userID AND acs = ''r'')');
		PREPARE query FROM @var; EXECUTE query;
		IF(@chek != NULL) THEN
			SET @id_ := NULL;
			SET @id__ := (SELECT id FROM my_chat.users WHERE log = login);
			SET @var = CONCAT('SET @id_ := (SELECT user_id FROM my_chat.part', @name, ' WHERE user_id = @id__)');
			PREPARE query FROM @var; EXECUTE query;
			IF(@id_ != NULL AND @id_ != @userID) THEN
				SET @var = CONCAT('UPDATE my_chat.part', @name, ' SET acs := ', _acs_,' WHERE user_id = @id_');
				PREPARE query FROM @var; EXECUTE query;
			ELSE
				SELECT 2;
			END IF;
		ELSE
			SELECT 1;
		END IF;

	COMMIT;
END//

DROP PROCEDURE IF EXISTS ONLINE;
CREATE PROCEDURE ONLINE()
BEGIN
	START TRANSACTION;
		SELECT unread_private_chats, unread_chats, request FROM my_chat.users WHERE id = @userID;
		UPDATE my_chat.users SET unread_private_chats := FALSE, unread_chats := FALSE, request := FALSE, last_tick := NOW() WHERE id = @userID;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GNM_PART_F_CHAT;
CREATE PROCEDURE GNM_PART_F_CHAT(n BIGINT UNSIGNED, m BIGINT UNSIGNED, like_ VARCHAR(50), chatID BIGINT UNSIGNED)
BEGIN
	-- START TRANSACTION;
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID,' WHERE id = chatID)');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SELECT log, acs FROM my_chat.users, my_chat.part', @name,' WHERE id = user_id AND log LIKE ''', like_,''' ORDER BY log ASC LIMIT ', n, ', ', m);
		PREPARE query FROM @var; EXECUTE query;
	-- COMMIT;
END//

DROP PROCEDURE IF EXISTS GNM_REQUESTS;
CREATE PROCEDURE GNM_REQUESTS(n BIGINT UNSIGNED, m BIGINT UNSIGNED, like_ VARCHAR(50))
BEGIN
	START TRANSACTION;
		SET @var := CONCAT('SELECT U.log, M.message FROM my_chat.r', @userID,' AS M, my_chat.users AS U WHERE U.log LIKE ''', like_,''' AND U.id = M.user_id ORDER BY M.last_tick DESC LIMIT ', n, ', ', m);
		PREPARE query FROM @var; EXECUTE query;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GNM_MESSAGES_P;
CREATE PROCEDURE GNM_MESSAGES_P(n BIGINT UNSIGNED, m BIGINT UNSIGNED, friendID BIGINT UNSIGNED)
BEGIN
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.p', @userID,' WHERE id = ', friendID, ')');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SET @unread_ := (SELECT unread FROM my_chat.p', @userID,' WHERE id = ', friendID, ')');
		PREPARE query FROM @var; EXECUTE query;
		IF (@unread_ = TRUE AND n = 0) THEN
			START TRANSACTION;
				SET @var = CONCAT('UPDATE my_chat.p', @userID, ' SET unread := FALSE, last_tick := last_tick WHERE id = ', friendID);
				PREPARE query FROM @var; EXECUTE query;
				UPDATE my_chat.users SET n_unread_private_chats := n_unread_private_chats - 1 WHERE id = @userID;
			COMMIT;
		END IF;
		SET @var = CONCAT('SELECT M.id, U.log, M.message, M.last_tick FROM my_chat.users AS U, my_chat.', @name,' AS M WHERE user_id = U.id ORDER BY M.id DESC LIMIT ', n, ', ', m);
		PREPARE query FROM @var; EXECUTE query;
END//

DROP PROCEDURE IF EXISTS GNM_MESSAGES_С;
CREATE PROCEDURE GNM_MESSAGES_С(n BIGINT UNSIGNED, m BIGINT UNSIGNED, chatID BIGINT UNSIGNED)
BEGIN
	-- START TRANSACTION;
		SET @var = CONCAT('SET @name := (SELECT name_of_messages_table FROM my_chat.c', @userID,' WHERE id = ', chatID, ')');
		PREPARE query FROM @var; EXECUTE query;
		SET @var = CONCAT('SET @unread_ := (SELECT unread FROM my_chat.c', @userID,' WHERE id = ', chatID, ')');
		PREPARE query FROM @var; EXECUTE query;
		IF (@unread_ = TRUE AND n = 0) THEN
			START TRANSACTION;
				SET @var = CONCAT('UPDATE my_chat.c', @userID, ' SET unread := FALSE, last_tick := last_tick WHERE id = ', chatID);
				PREPARE query FROM @var; EXECUTE query;
				UPDATE my_chat.users SET n_unread_chats := n_unread_chats - 1 WHERE id = @userID;
			COMMIT;
		END IF;
		SET @var = CONCAT('SELECT ID_M_.id, U.log, M.message, M.last_tick FROM my_chat.users AS U, my_chat.', @userID, '_', @name,' AS ID_M_, my_chat.', @name,' AS M WHERE M.user_id = U.id AND ID_M_.id_m = M.id ORDER BY ID_M_.id DESC LIMIT ', n, ', ', m);
		PREPARE query FROM @var; EXECUTE query;
	-- COMMIT;
END//

DROP PROCEDURE IF EXISTS GNM_CHATS;
CREATE PROCEDURE GNM_CHATS(n BIGINT UNSIGNED, m BIGINT UNSIGNED, like_ VARCHAR(50), ch CHARACTER(1))
BEGIN
	START TRANSACTION;
		IF (ch = 'p' OR ch = 'c') THEN
			SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT * FROM my_chat.', ch, @userID, ' AS LALKA');
			PREPARE query FROM @var; EXECUTE query;
			ALTER TABLE addressees ADD COLUMN num SERIAL;
			ALTER TABLE addressees ADD INDEX (num);
			ALTER TABLE addressees ADD COLUMN name VARCHAR(64);
			
			SET @i := 1;
			SET @max_ := (SELECT MAX(num) FROM addressees);
			IF (ch = 'p') THEN
				WHILE @i <= @max_ DO 
					SET @tmp_name := (SELECT name_of_messages_table FROM addressees WHERE num = @i);
					SET @var := CONCAT('UPDATE addressees SET name := (SELECT log FROM my_chat.users WHERE id IN (SELECT user_id FROM my_chat.part', @tmp_name, ') AND (id != @userID OR (1 = (SELECT COUNT(user_id) FROM my_chat.part', @tmp_name, '))) AND log LIKE ''', like_,''') WHERE num = @i');
					PREPARE query FROM @var; EXECUTE query;
					SET @i := @i + 1;
				END WHILE;
			ELSE
				WHILE @i <= @max_ DO
					SET @var := CONCAT('UPDATE addressees SET name := (SELECT N.name FROM my_chat.name', (SELECT name_of_messages_table FROM addressees WHERE num = @i), ' AS N WHERE N.name LIKE ''', like_,''')');
					PREPARE query FROM @var; EXECUTE query;
					SET @i := @i + 1;
				END WHILE;
			END IF;
			SELECT id, name FROM addressees ORDER BY last_tick DESC LIMIT n, m;
			DROP TABLE addressees;
		END IF;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GET_LAST_USER_TICK;
CREATE PROCEDURE GET_LAST_USER_TICK(login VARCHAR(40))
BEGIN
	START TRANSACTION;
		SELECT last_tick FROM my_chat.users WHERE log = login;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GET_USER_DATA;
CREATE PROCEDURE GET_USER_DATA(login VARCHAR(40))
BEGIN
	START TRANSACTION;
		SELECT status FROM my_chat.users WHERE log = login;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GNM_USERS;
CREATE PROCEDURE GNM_USERS(n BIGINT UNSIGNED, m BIGINT UNSIGNED, login VARCHAR(40))
BEGIN
	START TRANSACTION;
		SET @var := CONCAT('CREATE TEMPORARY TABLE addressees SELECT LALKA.name_of_messages_table FROM my_chat.p', @userID, ' AS LALKA');
		PREPARE query FROM @var; EXECUTE query;
		ALTER TABLE addressees ADD COLUMN num SERIAL;
		ALTER TABLE addressees ADD INDEX (num);
		ALTER TABLE addressees ADD COLUMN user_id BIGINT;
			
		SET @i := 1;
		SET @max_ := (SELECT MAX(num) FROM addressees);
		WHILE @i <= @max_ DO
			SET @tmp_name := (SELECT name_of_messages_table FROM addressees WHERE num = @i);
			SET @var := CONCAT('UPDATE addressees SET user_id := (SELECT user_id FROM my_chat.part', @tmp_name, ' WHERE (user_id != @userID OR (1 = (SELECT COUNT(user_id) FROM my_chat.part', @tmp_name, ')))) WHERE num = @i');
			PREPARE query FROM @var; EXECUTE query;
			SET @i := @i + 1;
		END WHILE;

		ALTER TABLE addressees DROP COLUMN num;
		ALTER TABLE addressees DROP COLUMN name_of_messages_table;

		SET @var := CONCAT('SELECT log FROM my_chat.users WHERE id <> ALL (SELECT user_id FROM addressees) AND id <> ALL (SELECT user_id FROM my_chat.r', @userID, ') AND log LIKE ''', login,''' ORDER BY last_tick DESC LIMIT ', n, ', ', m);
		PREPARE query FROM @var; EXECUTE query;
		DROP TABLE addressees;
	COMMIT;
END//

DROP PROCEDURE IF EXISTS GET_UNREAD_LAST_TICK;
CREATE PROCEDURE GET_UNREAD_LAST_TICK(id_ BIGINT UNSIGNED, ch CHARACTER(1))
BEGIN
	-- START TRANSACTION;
		IF (ch = 'p' OR ch = 'c') THEN
			SET @var := CONCAT('SELECT unread, last_tick FROM my_chat.', ch, @userID, ' WHERE id = ', id_);
			PREPARE query FROM @var; EXECUTE query;
		END IF;
	-- COMMIT;
END//

DELIMITER ;
-- --------------------------------------------------------------------------------------


Код, що описує сервер менеджер

Class MyException

#pragma once
#include<string>
using namespace std;
class MyException{
protected:
	string errorCause;
	int errorCode;
public:
	typedef int j;
	MyException(int errorCode, string errorCause = "") : errorCode(errorCode), errorCause(errorCause) {}
	// получить код ошибки
	int getErrorCode() const { return errorCode; }
	// получить объяснение
	string getErrorCause() { return string(errorCause.c_str()); }
	// оператор преобразования в стринг
	operator string(){
		return "Error:\nErrorCode is " + to_string(errorCode) + "\nErrorCause is " + errorCause;
	}
	virtual string toString(){
		return this->operator string();
	}
	virtual ~MyException(){}
};


class MyData

#pragma once
//обертка MyData позволяет хранить обект и непариться про засорение памяти при копировании.
//Если нужны данные, чтохранятся внутри - можно воспользоваться getData(),
//но тогда необходим нормальный публичным (public) копирующий конструктор у класса Т;
//в противном случае пользователь класса MyData берет ответственность сохранности данных на себя.
template<class T>
class MyData{
private:
	void* constructed_check;
	//отмечает конструирование объекта
	inline void constructing(){ constructed_check = (void*)this; }
	//проверка конструирования объекта
	inline bool constructed() const {
		if (constructed_check == (void*)this) return true;
		return false;
	}
	struct Node{ T data; unsigned long n; } *node;
	void init(const T &data){
		Node tmp = {data, unsigned long(1)};
		node = new Node(tmp);
		constructing();
	}
	void init(const MyData<T> &obj){
		node = obj.node;
		(node->n)++;
		constructing();
	}
	void destruct(){
		if (--(node->n) == 0)
			delete node;
	}
public:
	//возвращает количесто существующих объектов с тем же занчением поля data
	inline unsigned long num_of_copies() const { return (node->n) - 1; }
	inline MyData(const T &data){ init(data); }
	inline MyData(const MyData<T> &obj){ init(obj); }
	virtual inline ~MyData(){ destruct(); }
	inline MyData& operator=(const MyData<T>& obj){
		if (constructed()) destruct();
		init(obj);
		return *this;
	}

	(const T)* operator->(){ return (T*)node; }
	
	//возвращает данные, что хранятся тут,
	//в надежде на надежность конструктора копирования класса T
	inline T getData(){
		return node->data;
	}
	inline void setData(const T &data){
		destruct();
		init(data);
	}
};


class MySocket
#pragma once;
#include<string>
#include"MyException.h"
#pragma warning(disable : 4290)
using namespace std;

class MySocketException : public MyException{
public:
	MySocketException(int errorCode, string errorCause = "") : MyException(errorCode, errorCause){}
};

struct MySocketAddress{
	virtual char* get_ip () const = 0;
	virtual unsigned short get_port () const = 0;
	virtual ~MySocketAddress(){};
};

class MySocket{
public:	
	virtual ~MySocket () throw (MySocketException){}
	// привязка сокета к локальномы "имени сокета" (здесь)
  	virtual void bind (const MySocketAddress * const &address) throw (MySocketException) = 0;
	// отправить сообщение (отправляются len байт по адресу data)
	// возвращает количество отосланых байт
	virtual int sendto (const MySocketAddress * const &address, const char * const &data, const int &len) throw (MySocketException) = 0;
	// принять сообщение ожидаемой длины len
	// вернет либо количество полученных байт, либо 0. 0 вовсе не означает, что было получено 0 байт, это значение означает, сокет был закрыт до вызова recvfrom().
	virtual int recvfrom (MySocketAddress * &address, char * const &data, const int &len) throw (MySocketException) = 0;
	virtual int recvfrom (char * const &data, const int &len) throw (MySocketException) = 0;
	// отправить len байт (сокет уже должен быль привязан к внегнему адресу)
	// возвращает количество отосланых байт
	virtual int send (const char * const &data, const int &len) throw (MySocketException) = 0;
	// принять байты (не больше len)
	// вернет либо количество полученных байт, либо 0. 0 вовсе не означает, что было получено 0 байт, это значение означает, сокет был закрыт до вызова recv().
	virtual int recv (char * const &data, const int &len) throw (MySocketException) = 0;
	// обертка над send. пишет все len байт из data, когда send может записать не все
	virtual int write (const char * const &data, const int &len) throw (MySocketException) = 0;
	// обертка над recv. пытается читать все len байт в data (ждет, пока не придут все len байт), когда recv может читать только те данные, которые пришли на данный момент
	virtual int read (char * const &data, const int &len) throw (MySocketException) = 0;
	// привязка сокета к глобальному "имени сокета" (в сети)
	virtual void connect (const MySocketAddress * const &address) throw (MySocketException) = 0;
	// можно вызвать только для сокетов после вызова bind и перед вызовом accept
	// переводит совет в состояние listen
	// параметр backlog задает задает максимальное число соединений.
	virtual void listen (const int &backlog) throw (MySocketException) = 0;
	// возвращает указатель на сокет, который образовался в результате запроса на подсоединение к серверу, за который отвечает этот сокет.
	// в address записывается адресс, от куда поступил запрос
	virtual MySocket* accept (MySocketAddress * &address) throw (MySocketException) = 0;
	virtual MySocket* accept () throw (MySocketException) = 0;
};


MyWinSocket.h
#pragma once
#pragma comment(lib, "ws2_32.lib")//подключение библиотеки win_sock_2.0 (как я думаю, для 32 бит)
#include<WinSock2.h>
#include"MySocket.h"
#include"MyData.h"

class MyWinSocketException : public MySocketException{
public:
	MyWinSocketException(int errorCode, string errorCause = "") : MySocketException(errorCode, errorCause){}
};

class MyWinSocketAddress : public MySocketAddress{
private:
	MyData<sockaddr_in> ad;
public:
	MyWinSocketAddress(const char * const &ip = "", const unsigned short &port = 0) throw (MyWinSocketException);
	MyWinSocketAddress(const sockaddr& addr) throw (MyWinSocketException);
	MyWinSocketAddress(const sockaddr_in& addr) throw (MyWinSocketException);
	virtual char* get_ip() const{ return inet_ntoa(((MyData<sockaddr_in>)ad)->sin_addr); }
	virtual unsigned short get_port() const { return ntohs(((MyData<sockaddr_in>)ad)->sin_port); }
	operator sockaddr(){return *((sockaddr*)&ad.getData()); }
};

class MyWinSocket : public MySocket{
protected:
	MyData<SOCKET> socket;
	//счетчик объектов этого класса
	static unsigned long n;
public:
	MyWinSocket(const int &type = SOCK_STREAM) throw (MyWinSocketException);
	virtual ~MyWinSocket() throw (MyWinSocketException);
	// привязка сокета к "имени сокета"
	virtual void bind (const MySocketAddress * const &address) throw (MyWinSocketException);
	// отправить сообщение (отправляются len байт по адресу в data)
	// возвращает количество отосланых байт
	virtual int sendto (const MySocketAddress * const &address, const char * const &data, const int &len) throw (MySocketException);
	// принять сообщение ожидаемой длины len
	// вернет либо количество полученных байт, либо 0. 0 вовсе не означает, что было получено 0 байт, это значение означает, сокет был закрыт до вызова recvfrom().
	virtual int recvfrom (MySocketAddress * &address, char * const &data, const int &len) throw (MySocketException);
	virtual int recvfrom (char * const &data, const int &len) throw (MySocketException);
	// отправить len байт (сокет уже должен быль привязан к внегнему адресу)
	// возвращает количество отосланых байт
	virtual int send (const char * const &data, const int &len) throw (MySocketException);
	// принять байты (не больше len)
	// вернет либо количество полученных байт, либо 0. 0 вовсе не означает, что было получено 0 байт, это значение означает, сокет был закрыт до вызова recv().
	virtual int recv (char * const &data, const int &len) throw (MySocketException);
	// привязка сокета к глобальному "имени сокета" (в сети)
	// обертка над send. пишет все len байт из data, когда send может записать не все
	virtual int write (const char * const &data, const int &len) throw (MySocketException);
	// обертка над recv. пытается читать все len байт в data (ждет, пока не придут все len байт), когда recv может читать только те данные, которые пришли на данный момент
	virtual int read (char * const &data, const int &len) throw (MySocketException);
	// привязка сокета к глобальному "имени сокета" (в сети)
	virtual void connect (const MySocketAddress * const &address) throw (MySocketException);
	// можно вызвать только для сокетов после вызова bind и перед вызовом accept
	// переводит совет в состояние listen
	// параметр backlog задает задает максимальное число соединений.
	virtual void listen (const int &backlog = SOMAXCONN) throw (MySocketException);
	// возвращает указатель на сокет, который образовался в результате запроса на подсоединение к серверу, за который отвечает этот сокет.
	// в address записывается адресс, от куда поступил запрос
	virtual MySocket* accept (MySocketAddress * &address) throw (MySocketException);
	virtual MySocket* accept () throw (MySocketException);
};




MyWinSocket.cpp
#include"MyWinSocket.h"

inline static void init_winSocket() throw (MyWinSocketException) {
	WORD winSock_version = MAKEWORD(2, 0); // запрашиваем winsock версии 2.0
	WSADATA winSock_data;	// сюда будут помещены данные об инициализированном интерфейсе winsock

	int error = WSAStartup (winSock_version, &winSock_data);	// непосредственно инициализция
	if (error != 0)
		throw MyWinSocketException(GetLastError(), "initSock: could not initialize winSock.");
}
inline static void cleanup_winSocket() throw (MyWinSocketException){
	int error = WSACleanup();
	if (error != 0)
		throw MyWinSocketException(GetLastError(), "cleanSock: could not perform cleaning up.");
}

inline static sockaddr_in make_sockaddr_in(const char * const &ip, const unsigned short &port){
	sockaddr_in ad;
	ad.sin_family = AF_INET;
	if (strcmp(ip, "") == 0) ad.sin_addr.s_addr = INADDR_ANY;
	else ad.sin_addr.s_addr = inet_addr (ip);
	if (ad.sin_addr.s_addr == INADDR_NONE) throw MyWinSocketException(GetLastError(), "WinSocketAddress: the provided IP address seems to be invalid.");
	ad.sin_port = htons (port);
	return ad;
}
MyWinSocketAddress::MyWinSocketAddress(const char * const &ip, const unsigned short &port) throw (MyWinSocketException) : ad(make_sockaddr_in(ip, port)) {}
inline static sockaddr_in make_sockaddr_in(const sockaddr_in &addr){
	if (addr.sin_addr.s_addr == INADDR_NONE) throw MyWinSocketException(GetLastError(), "WinSocketAddress: the provided IP address seems to be invalid.");
	return addr;
}
MyWinSocketAddress::MyWinSocketAddress(const sockaddr_in &addr) throw (MyWinSocketException) : ad(make_sockaddr_in(addr)) {}
MyWinSocketAddress::MyWinSocketAddress(const sockaddr& addr) throw (MyWinSocketException) : ad(make_sockaddr_in(*((sockaddr_in*)&addr))) {}


unsigned long MyWinSocket::n = 0;
MyWinSocket::MyWinSocket(const int &type) throw (MyWinSocketException) : socket(0){
	if (n++ == 0) init_winSocket();
	SOCKET sock = ::socket(PF_INET, type, 0);
	if (sock == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket: could not create a WinSocket.");
	socket.setData(sock);
}
MyWinSocket::~MyWinSocket() throw (MyWinSocketException){
	if (this->socket.num_of_copies() == 0){
		int error = closesocket (socket.getData()); // закрываем сокет
		if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "~WinSocket: could not close WinSocket properly");
		if (--n == 0) cleanup_winSocket();
	}
}
void MyWinSocket::bind(const MySocketAddress * const &address) throw (MyWinSocketException){
	MyWinSocketAddress addr(address->get_ip(), address->get_port());
	int error = ::bind(socket.getData(), &((sockaddr)addr), sizeof(sockaddr_in));
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::bind: could not bind socket to a provided address.");
}
int MyWinSocket::sendto (const MySocketAddress * const &address, const char * const &data, const int &len) throw (MySocketException){
	MyWinSocketAddress addr(address->get_ip(), address->get_port());
	int error = ::sendto (socket.getData(), data, len, 0, &((sockaddr)addr), sizeof(sockaddr_in));
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::sendto: could not send data.");
	return error;
}
int MyWinSocket::recvfrom (MySocketAddress * &address, char * const &data, const int &len) throw (MySocketException){
	int address_len = sizeof(sockaddr_in);
	sockaddr *address_ = new sockaddr;
	int error = ::recvfrom (socket.getData(), data, len, 0, address_, &address_len);
	if (error == SOCKET_ERROR || address_len != sizeof(sockaddr_in)) throw MyWinSocketException(GetLastError(), "WinSocket::recvfrom: could not receive data.");
	address = (MySocketAddress*)(new MyWinSocketAddress(*address_));
	delete address_;
	return error;
}
int MyWinSocket::recvfrom (char * const &data, const int &len) throw (MySocketException){
	int error = ::recvfrom (socket.getData(), data, len, 0, nullptr, nullptr);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::recvfrom: could not receive data.");
	return error;
}
int MyWinSocket::send (const char * const &data, const int &len) throw (MySocketException){
	int error = ::send (socket.getData(), data, len, 0);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::send: could not send data.");
	return error;
}
int MyWinSocket::recv (char * const &data, const int &len) throw (MySocketException){
	int error = ::recv (socket.getData(), data, len, 0);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::recv: could not receive data.");
	return error;
}
int MyWinSocket::write (const char * const &data, const int &len) throw (MySocketException){
	int _len = len, error = 0;
	char *ptr = (char*)data;
	do{ error = ::send (socket.getData(), (ptr = ptr + error), _len, 0); }while(error > 0 && (_len = _len - error) > 0 || error == SOCKET_ERROR && GetLastError() == WSAEINTR);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::write: could not write data.");
	return len - _len;
}
int MyWinSocket::read (char * const &data, const int &len) throw (MySocketException){
	int _len = len, error = 0;
	char *ptr = data;
	do{ error = ::recv (socket.getData(), (ptr = ptr + error), _len, 0); }while(error > 0 && (_len = _len - error) > 0 || error == SOCKET_ERROR && GetLastError() == WSAEINTR);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::read: could not read data.");
	return len - _len;
}
void MyWinSocket::connect (const MySocketAddress * const &address) throw (MySocketException){
	MyWinSocketAddress addr(address->get_ip(), address->get_port());
	int error = ::connect(socket.getData(), &((sockaddr)addr), sizeof(sockaddr_in));
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::connect: could not connect socket to a provided address.");
}
void MyWinSocket::listen (const int &backlog) throw (MySocketException){
	int error = ::listen(socket.getData(), backlog);
	if (error == SOCKET_ERROR) throw MyWinSocketException(GetLastError(), "WinSocket::listen: could not make listen socket.");
}
MySocket* MyWinSocket::accept (MySocketAddress * &address) throw (MySocketException){
	int address_len = sizeof(sockaddr_in);
	sockaddr *address_ = new sockaddr;
	SOCKET sock = ::accept(socket.getData(), address_, &address_len);
	if (sock == INVALID_SOCKET || address_len != sizeof(sockaddr_in)) throw MyWinSocketException(GetLastError(), "WinSocket::accept: could not accsept connection.");
	address = (MySocketAddress*)(new MyWinSocketAddress(*address_));
	delete address_;
	MyWinSocket * res = new MyWinSocket(*this);
	res->socket.setData(sock);
	n++;
	return (MySocket*)res;
}
MySocket* MyWinSocket::accept () throw (MySocketException){
	SOCKET sock = ::accept(socket.getData(), nullptr, nullptr);
	if (sock == INVALID_SOCKET) throw MyWinSocketException(GetLastError(), "WinSocket::accept: could not accsept connection.");
	MyWinSocket * res = new MyWinSocket(*this);
	res->socket.setData(sock);
	n++;
	return (MySocket*)res;
}


usingClasses.h

#pragma once
#include"MyWinSocket.h"
#include"MyData.h"

#pragma region usingClasses
unsigned int my_strlen(const char * const &s){
	if (s == nullptr) return 0;
	const char *res = s;
	for (; *res != '\0'; res++){}
	return res - s;
}
class charPtr{
	typedef char T;
	MyData<T*> ptr;
	unsigned short len;//не менять тип!
	void destr(){
		if(ptr.num_of_copies() == 0) delete ptr.getData();
	}
public:
	charPtr() : ptr(nullptr), len(0){}
	//использовать только когда в конце есть нулевой байт
	charPtr(const T* const &ptr) : ptr(nullptr){
		init(ptr, my_strlen(ptr));
	}
	charPtr(const T* const &ptr, const unsigned short &len) : ptr(nullptr){
		init(ptr, len);
	}
	charPtr(T* const &ptr, const unsigned short &len) : ptr(nullptr){
		init(ptr, len);
	}
	void init(T* const &ptr, const unsigned short &len){
		destr();
		this->len = len;
		this->ptr.setData((T*)ptr);
	}
	void init(const T* const &ptr, const unsigned short &len){
		char *buf = new char[len];
		for (char* tmp1 = buf, *tmp2 = (char*)ptr, *end = buf + len; tmp1 != end; *tmp1++ = *tmp2++){}
		this->init(buf, len);
	}
	~charPtr(){
		destr();
	}
	unsigned short getLen() const{
		return len;
	}
	//за объект класса Т, что возвращается этим методом по указателю Т*, создатель класса template<class T> class Ptr не несет ответственности
	T* getPtr() const{
		return ((MyData<T*>)ptr).getData();
	}
	operator bool(){
		if(this->getPtr()) return true;
		return false;
	}
};
ostream& operator<<(ostream& stream, const charPtr &obj){
	char *ptr = obj.getPtr(), *end = ptr + obj.getLen();
	for (;ptr < end;) stream.put(*ptr++);
	return stream;
}
bool operator<(const charPtr &left, const charPtr &right){
	if (left.getLen() < right.getLen()) return true;
	else if(left.getLen() > right.getLen()) return false;
	for(char *ptr1 = left.getPtr(), *ptr2 = right.getPtr(), * const end = left.getPtr() + left.getLen() - 1; ptr1 <= end; ptr1++, ptr2++){
		if((*ptr1) < (*ptr2)) return true;
		else if((*ptr1) > (*ptr2)) return false;
	}
	return false;
}
bool operator ==(const charPtr &left, const charPtr &right){
	if(left.getLen() != right.getLen()) return false;
	for(char *ptr1 = left.getPtr(), *ptr2 = right.getPtr(), * const end = left.getPtr() + left.getLen() - 1; ptr1 <= end; ptr1++, ptr2++){
		if((*ptr1) != (*ptr2)) return false;
	}
	return true;
}
bool operator >(const charPtr &left, const charPtr &right){
	if (left.getLen() > right.getLen()) return true;
	else if(left.getLen() < right.getLen()) return false;
	for(char *ptr1 = left.getPtr(), *ptr2 = right.getPtr(), * const end = left.getPtr() + left.getLen() - 1; ptr1 <= end; ptr1++, ptr2++){
		if((*ptr1) > (*ptr2)) return true;
		else if((*ptr1) < (*ptr2)) return false;
	}
	return false;
}
bool operator !=(const charPtr &left, const charPtr &right){
	return !(left == right);
}
charPtr operator+(const charPtr &left, const charPtr &right){
	char *buf = new char[left.getLen() + right.getLen()], *ptr1 = left.getPtr(), *ptr2 = right.getPtr();
	for (char* end = buf + left.getLen(); buf < end; *buf++ = *ptr1++){}
	for (char* end = buf + right.getLen(); buf < end; *buf++ = *ptr2++){}
	buf -= left.getLen() + right.getLen();
	return charPtr(buf, left.getLen() + right.getLen());
}
charPtr operator+(const charPtr &left, const char * const &right){
	return left + charPtr(right);
}
charPtr operator+(const char * const &left, const charPtr &right){
	return charPtr(left) + right;
}

class MySocketPtr{
	typedef MySocket* T;
	MyData<T> data;
public:
	MySocketPtr(const T &sock) : data(sock){}
	~MySocketPtr(){
		if(data.num_of_copies() == 0) delete data.getData();
	}
	T operator->(){
		return data.getData();
	}
};

#pragma region for_socket

/**
	общение с клиентом:
		-по протоколу TCP.
		-в заглавие каждго сообщения ложется 2 байта, которые представляют из себя целое неотрицательное число [0; 256 * 256 - 1] записаное в порядке байт от старшего к младшему.
	таким образом каждая сторона будет знать, какой длины сообшение ожидать.
 **/

 //отправляет len байт по адресу str, отправляя перед ними количество отправляемых байт (то есть len)
void writestr(MySocketPtr sock, const char* const &str, const unsigned short &len) throw (MySocketException) {
	char len_[] = {len / 256, len % 256};
	sock->write(len_, 2);
	if (len != 0) sock->write(str, len);
}
MySocketPtr& operator<<(MySocketPtr &sock, const charPtr &ptr){
	writestr(sock, ptr.getPtr(), ptr.getLen());
	return sock;
}
MySocketPtr& operator<<(MySocketPtr &sock, const char * const &ptr){
	writestr(sock, ptr, strlen(ptr));
	return sock;
}

//принимает в str, отправленное к нам некоторое количество байт, и записывает это количество в len
//str на входе должна быть не инициализированой
void readstr(MySocketPtr sock, char *&str, unsigned short &len) throw (MySocketException) {
	char len_[2];
	if (sock->read(len_, 2)) len = len_[0] * 256 + len_[1];
	else len = 0;
	try{
		if (len != 0){
			str = new char[len];
			sock->read(str, len);
		} else str = nullptr;
	} catch(...) {
		delete str;
		throw;
	}
}
MySocketPtr& operator>>(MySocketPtr &sock, charPtr &ptr){
	char* buf;
	unsigned short len;
	readstr(sock, buf, len);
	ptr.init(buf, len);
	return sock;
}

#pragma endregion

#pragma endregion


main.cpp

#include "usingClasses.h"
#pragma comment(lib, "libmysql.lib") // подключаем библиотеку
#include <mysql.h>
#include<iostream>

#pragma region TheProgramm

//возможные команды
enum command {authorization, registration};
enum key {check, sender_private_message, sender_chat_message, sender_request, accepter_request, creater_chat, adder_part, line, seter_access, get_user_data, get_last_user_tick, geter_n_m_partners_from, geter_n_m_requests, geter_n_m_messages_p, geter_n_m_messages_c, geter_n_m_friens, geter_n_m_confs, geter_n_m_users, geter_freand_unread_last_tick, geter_conf_unread_last_tick, get_friend_id};
const char* buf;
string sbuf;

const unsigned short
	//количество команд, количество ответов, количество ключей команды авторизации.
	n_commands = 2, n_answers = 2, n_aut_keys = 21,
	//максимальное количество байт для логина, максимальное количество байт для пароля.
	max_login_len = 40, max_password_len = 40;


const charPtr
	commands[n_commands] = {"aut", "reg"},//массив команд
	answers[n_answers] = {"0", "1"},//массив ответов //0 - OK, 1 - ERROR
	aut_keys[n_aut_keys ] = {"check", "smp", "smc", "sr", "ar", "cc", "ap", "line", "sa", "gud", "glut", "gnmp", "gnmr", "gnmmp", "gnmc", "gnmf", "gnmco", "gnmu", "gful", "gcul", "gfid"},//массив ключей команды авторизации
	authorized("authorized."),
	registered("registered."),
	error("ERROR: "),
	warning("WARNING: "),
	key("key \' "),
	user("user \' "),
	authorization_error("incorrect autorisation parametres."),
	authorization_key_error(" \' is unknown authorization key."),
	registration_error(" \' is already exist."),
	wasnt_authorizated("You are not logged in."),
	unknown_command(" is unknown command."),
	null_symbol("\0", 1),
	login_len_error((string("\nYoure login is to long. max length of login is ") + to_string(max_login_len) + ".").c_str()),
	password_len_error((string("\nYoure password is to long. max length of password is ") + to_string(max_password_len) + ".").c_str());

 /**
	общение с клиентом:
		-клиент подключается к серверу и выполняет либо регистрацию, либо авторизацию.
		-при авторизации клиент указывае ключ, который определяет, за какое действие будет отвечать это соединение.
	смысл заключается в том, что клиент должен авторизроваться для того, чтоб получить соеденение, которое будет отвечать за конкретное действие, а действий может быть много и для полноценной работы клиента необходимо иметь хотя бы по одному соединению для каждого действия (так проще писать программу)
	клиент знает количество команд, значение кажной команды (смысл), и порядок, в котором они должны придти.
		-каждый запрос - команда и некоторые параметры.(параметры присылаются отдельно от запроса - не склеянные в одно сообщение, а разделенные байтами, которые отвечают за длину)
 **/

 /**
	смысл команд:

		-authorization login password key: авторизация
	(length of login <= max_login_len и length of password <= max_password_len)
	при удачной авторизации клиенту вернется сообщение соответствующего содержания; сервер переводит соеденение с клиентом в состояние соответствующие ключу key.

		-registration login password: регистрация
	(length of login <= max_login_len и length of password <= max_password_len)
	при удачной регистрации клиенту вернется сообщение соответствующего содержания.
 **/

#pragma region UserBaseManager

typedef MYSQL UBD;//UserBaseDescriptor

UBD *MD;//MainDescriptor
string Mhost, Muser, Mpassword;
unsigned int Mport;

//возвращает объект типа charPtr с удвоенными апострофами.
//если непоместится - вернет пустой объект типа charPtr.
charPtr mono_to_di_apostrophe(charPtr ptr){
	unsigned short n = ptr.getLen();
	unsigned int new_n = 0;
	char *source_ptr = ptr.getPtr(), *new_ptr;
	for (unsigned short i = 0; i < n; i++){ if(source_ptr[i] == '\'') new_n++; }
	new_n += n;
	if(new_n > 64000) return charPtr();
	new_ptr = new char[new_n];
	for (unsigned short i = 0, j = 0; i < n; i++, j++){
		new_ptr[j] = source_ptr[i];
		if(source_ptr[i] == '\'') new_ptr[++j] = '\'';
	}
	return charPtr(new_ptr, new_n);
}
//возвращает объект типа charPtr в котором удвоенные апострофы стали одиназными.
//если есть одинарный апостроф - вернет пустой объект типа charPtr.
charPtr di_to_mono_apostrophe(charPtr ptr){
	unsigned short n = ptr.getLen();
	unsigned int new_n = 0;
	char *source_ptr = ptr.getPtr(), *new_ptr;
	for (unsigned short i = 0; i < n; i++){
		if(source_ptr[i] == '\''){
			if(((i + 1) != n) && (source_ptr[i + 1] == '\'')){
				new_n++;
				i++;
			} else return charPtr();
		}
	}
	new_n = n - new_n / 2;
	new_ptr = new char[new_n];
	for (unsigned short i = 0, j = 0; i < n; i++, j++){
		if(source_ptr[i] == '\'') {
			new_ptr[j] = '\''; 
			i++;
		}
		else new_ptr[j] = source_ptr[i];
	}
	return charPtr(new_ptr, new_n);
}
charPtr insert_first_bifor_second(charPtr ptr, char first, char second){
	unsigned short n = ptr.getLen();
	unsigned int new_n = 0;
	char *source_ptr = ptr.getPtr(), *new_ptr;
	for (unsigned short i = 0; i < n; i++){ if(source_ptr[i] == second) new_n++; }
	new_n += n;
	if(new_n > 64000) return charPtr();
	new_ptr = new char[new_n];
	for (unsigned short i = 0, j = 0; i < n; i++, j++){
		if(source_ptr[i] == second) new_ptr[j++] = first;
		new_ptr[j] = source_ptr[i];
	}
	return charPtr(new_ptr, new_n);
}

// вернет ID пользователя, если такой есть, и charPtr с nullptr указателем на строку, если такого нет
charPtr authorize(charPtr login, charPtr passwodr) throw (MyException){
	charPtr res;
	UBD *desc = mysql_init(NULL);
	mysql_real_connect(desc, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS);
	if(mysql_query(desc, ("CALL my_chat.AUT('" + mono_to_di_apostrophe(login) + "','" + mono_to_di_apostrophe(passwodr) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
	MYSQL_RES *query_res = mysql_store_result(desc);
    auto num_rows = mysql_num_rows(query_res); // количество строк.
	if (num_rows){
		const char * const buf = mysql_fetch_row(query_res)[0]; //const char * const потому, что тогда в res будет копироваться строка и после вызова mysql_free_result(query_res) деструктор объекта res выполнется нормально
		res.init(buf, strlen(buf));
	}
	mysql_free_result(query_res); // Очищаем результаты
	mysql_close(desc); // Закрываем соединение
	return res;
}
bool existUser(charPtr login) throw (MyException){
	bool res = false;
	UBD *desc = mysql_init(NULL);
	mysql_real_connect(desc, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS);
	if(mysql_query(desc, ("CALL my_chat.GET_USER_ID('" + mono_to_di_apostrophe(login) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
	MYSQL_RES *query_res = mysql_store_result(desc);
	if (mysql_num_rows(query_res)) res = true;
	mysql_free_result(query_res);
	mysql_close(desc);
	return res;
}
void addUser(charPtr login, charPtr passwodr){
	bool res = false;
	UBD *desc = mysql_init(NULL);
	mysql_real_connect(desc, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS);
	if(mysql_query(desc, ("CALL my_chat.ADDUSER('" + mono_to_di_apostrophe(login) + "','" + mono_to_di_apostrophe(passwodr) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
	mysql_close(desc);
}

//void dellUser(charPtr login){
//	
//}

////отвечает за соединение, для отправки приватных сообщений
//void sender_p_m(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr friendID, message;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		//friendID - не id пользователя базы данных, а id записи в списке друзей
//		sock >> friendID >> message;
//		if(mysql_query(desc, ("CALL SEND_P_M(" + friendID + ",'" + mono_to_di_apostrophe(message) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not send the message.");
//		else sock << answers[0];
//	}
//}
//void sender_c_m(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr chatID, message;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> chatID >> message;
//		if(mysql_query(desc, ("CALL SEND_C_M(" + chatID + ",'" + mono_to_di_apostrophe(message) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not send the message.");
//		else sock << answers[0];
//	}
//}
////если пользователю отправляется заявка не первый раз, то она обновится.
//void send_request(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr userLOGIN, diuserLOGIN, message;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> userLOGIN >> message;
//		diuserLOGIN = mono_to_di_apostrophe(userLOGIN);
//		if(mysql_query(desc, ("CALL GET_USER_ID('" + diuserLOGIN + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n == 0){
//			sock << answers[1] << warning + "there is no user with login:\n" + userLOGIN;
//			continue;
//		}
//		if(mysql_query(desc, ("CALL SEND_REQUEST('" + diuserLOGIN  +"', '" + mono_to_di_apostrophe(message) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n){
//			sock << answers[1] << warning + "user \" " + userLOGIN + " \" is your friend already.";
//			continue;
//		}
//		else sock << answers[0];
//	}
//}
//void accept_request(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr login;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> login;
//		if(mysql_query(desc, ("CALL ACCEPT_REQUEST(" + mono_to_di_apostrophe(login) + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not accept the request.");
//		else sock << answers[0];
//	}
//}
//void creat_chat(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr name_of_chat, DEFAULT;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> name_of_chat >> DEFAULT;
//		if (DEFAULT.getLen() != 1 || (DEFAULT.getPtr()[0] != 'u' && DEFAULT.getPtr()[0] != 'g')) throw MyException(1, "could not accept the request.");
//		if (name_of_chat.getLen() > 64){
//			sock << answers[1] << warning + "maximal length of name for chat is 64.";
//			continue;
//		}
//		if(mysql_query(desc, ("CALL CREATE_CHAT('" + mono_to_di_apostrophe(name_of_chat) + "', '" + DEFAULT + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not accept the request.");
//		else sock << answers[0];
//	}
//}
//void add_part(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr friendID, chatID;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> friendID >> chatID;
//		if(mysql_query(desc, ("CALL IS_FRIEND_IN_CHAT(" + friendID + ", " + chatID + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n){
//			sock << answers[1] << warning + "your friend have been in chat allready.";
//			continue;
//		}
//		//выполнит ся при условии, что friendID - в друзьях и отправитель в chatID как минимум granted и что friendID не в chatID
//		if(mysql_query(desc, ("CALL ADD_PART(" + friendID + ", " + chatID + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not accept the request.");
//		else sock << answers[0];
//	}
//}
//void set_access(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr login, chatID, acs;
//	my_ulonglong n;
//	MYSQL_RES *query_res;
//	while(true){
//		sock >> login >> chatID >> acs;
//		if(mysql_query(desc, ("CALL SET_ACCESS('" + mono_to_di_apostrophe(login) + "', " + chatID + ", '" + acs + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n = mysql_num_rows(query_res);
//		mysql_free_result(query_res);
//		if (n) throw MyException(1, "could not accept the request.");
//		else sock << answers[0];
//	}
//}
//void online(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr tmp;
//	MYSQL_RES *query_res;
//	MYSQL_ROW row;
//	while(true){
//		sock >> tmp;
//		if(mysql_query(desc, "CALL ONLINE()") > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		row = mysql_fetch_row(query_res);
//		sock << answers[0] << row[0] << row[1] << row[2];
//		mysql_free_result(query_res);
//	}
//}
//void get_n_m_partners_from(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	//если все ок - вернет логины участников чата и к каждому из них 1 - (незабанин) или 0 - (забанен)
//	charPtr n, m, chatID; //n - начиная с какого (счет нач с 0), m - сколько
//	charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	MYSQL_ROW row;
//	while(true){
//		sock >> n >> m >> like >> chatID;
//		if(mysql_query(desc, ("CALL GNM_PART_F_CHAT(" + n + ", " + m + ", '" + mono_to_di_apostrophe(like) + "%', " + chatID + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
//		for (int i = 0; i < n_rows; i++){
//			row = mysql_fetch_row(query_res);
//			sock << di_to_mono_apostrophe((const char*)row[0]);
//			if (charPtr((const char*)row[1]) == charPtr("NULL")) sock << "0";
//			else sock << "1";
//		}
//		mysql_free_result(query_res);
//	}
//}
//void get_n_m_requests(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	//смотрит приглашения в друзь
//	//если все ок - вернет логины и сообщение и сообщение к каждому из логинов
//	charPtr n, m; //n - начиная с какого (счет нач с 0), m - сколько
//	charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	MYSQL_ROW row;
//	while(true){
//		sock >> n >> m >> like;
//		if(mysql_query(desc, ("CALL GNM_REQUESTS(" + n + ", " + m + ", '" + mono_to_di_apostrophe(like) + "%')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
//		for (int i = 0; i < n_rows; i++){
//			row = mysql_fetch_row(query_res);
//			sock << di_to_mono_apostrophe((const char*)row[0]) << di_to_mono_apostrophe((const char*)row[1]);
//		}
//		mysql_free_result(query_res);
//	}
//}
////p - false, c - true;
//void get_n_m_messages(UBD *desc, MySocketPtr sock, bool p_or_c) throw (MyException, MySocketException){
//	//читает сообщения из конференции
//	//если все ок - вернет количество сообщений, {id сообщения, сообщение, логин отправителя, время}
//	charPtr n, m, ID; //n - начиная с какого (счет нач с 0), m - сколько
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	MYSQL_ROW row;
//	while(true){
//		sock >> n >> m >> ID;
//		if (p_or_c){
//			if(mysql_query(desc, ("CALL GNM_MESSAGES_С(" + n + ", " + m + ", " + ID + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		} else {
//			if(mysql_query(desc, ("CALL GNM_MESSAGES_P(" + n + ", " + m + ", " + ID + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		}
//		query_res = mysql_store_result(desc);
//		sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
//		for (int i = 0; i < n_rows; i++){
//			row = mysql_fetch_row(query_res);
//			sock << row[0] << di_to_mono_apostrophe((const char*)row[1]) << di_to_mono_apostrophe((const char*)row[2]) << row[3];
//		}
//		mysql_free_result(query_res);
//	}
//}
////friends - false, confs - true;
//void get_n_m_chats(UBD *desc, MySocketPtr sock, bool friends_or_confs) throw (MyException, MySocketException){
//	//возвращает список конференций или друзей
//	//если все ок - вернет количество сообщений, {id чата, имя чата}
//	charPtr n, m, ch; //n - начиная с какого (счет нач с 0), m - сколько
//	charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	MYSQL_ROW row;
//	while(true){
//		sock >> n >> m >> like;
//		if (friends_or_confs) ch = charPtr("c");
//		else ch = charPtr("p");
//		if(mysql_query(desc, ("CALL GNM_CHATS(" + n + ", " + m + ", '" + mono_to_di_apostrophe(like) + "%', '" + ch + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
//		for (int i = 0; i < n_rows; i++){
//			row = mysql_fetch_row(query_res);
//			sock << row[0] << di_to_mono_apostrophe((const char*)row[1]);
//		}
//		mysql_free_result(query_res);
//	}
//}
//void get_n_m_users(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	//возвращает пользователей
//	//если все ок - вернет количество сообщений, {логин пользователя}
//	charPtr n, m; //n - начиная с какого (счет нач с 0), m - сколько
//	charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	MYSQL_ROW row;
//	while(true){
//		sock >> n >> m >> like;
//		if(mysql_query(desc, ("CALL GNM_USERS(" + n + ", " + m + ", '" + mono_to_di_apostrophe(like) + "%')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
//		for (int i = 0; i < n_rows; i++){
//			row = mysql_fetch_row(query_res);
//			sock << row[0];
//		}
//		mysql_free_result(query_res);
//	}
//}
//void get_u_data(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr login;
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	while(true){
//		sock >> login;
//		if(mysql_query(desc, ("CALL GET_USER_DATA('" + mono_to_di_apostrophe(login) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n_rows = mysql_num_rows(query_res);
//		if (n_rows) sock << answers[0] << mysql_fetch_row(query_res)[0];
//		mysql_free_result(query_res);
//		if (n_rows == 0) throw MyException(1, "could not get user data.");
//	}
//}
//void get_last_u_tick(UBD *desc, MySocketPtr sock) throw (MyException, MySocketException){
//	charPtr login;
//	MYSQL_RES *query_res;
//	my_ulonglong n_rows;
//	while(true){
//		sock >> login;
//		if(mysql_query(desc, ("CALL GET_LAST_USER_TICK('" + mono_to_di_apostrophe(login) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
//		query_res = mysql_store_result(desc);
//		n_rows = mysql_num_rows(query_res);
//		if (n_rows) sock << answers[0] << mysql_fetch_row(query_res)[0];
//		mysql_free_result(query_res);
//		if (n_rows == 0) throw MyException(1, "could not get last user tick.");
//	}
//}
#pragma endregion

//вернет тру, если в ptr есть символ из tabu_chars.
bool tabu_chars(charPtr ptr, charPtr tabu_chars){
	unsigned short n1 = ptr.getLen(), n2 = tabu_chars.getLen();
	char *c1 = ptr.getPtr(), *c2 = tabu_chars.getPtr();
	for (int i = 0; i < n1; i++){
		for (int j = 0; j < n2; j++){
			if (c1[i] == c2[j]) return true;
		}
	}
	return false;
}

void init_connection_for_work(UBD *&desc, charPtr userID) throw (MyException) {
	try{ if(mysql_query(desc, "USE my_chat") > 0) throw MyException(mysql_errno(desc), mysql_error(desc));//два раза, потому, что первый раз может не зайти
	}catch(MyException ex){
		if (ex.getErrorCode() != 2013){
			mysql_close(desc);
			desc = mysql_init(NULL);
			mysql_real_connect(desc, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS);// без флага CLIENT_MULTI_STATEMENTS не получится запускать хранимые процедуры
		}
		if(mysql_query(desc, "USE my_chat") > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
	}
	if(mysql_query(desc, ("SET @userID := " + userID + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
}

//вернуть номер команды
//если такой команды нет - вернет количество команд
unsigned short get_cmd_num(charPtr ptr){
	for(unsigned short i = 0; i < n_commands; i++){
		if (ptr == commands[i]) return i;
	}
	return n_commands;
}
unsigned short get_aut_key_num(charPtr ptr){
	for(unsigned short i = 0; i < n_aut_keys; i++){
		if (ptr == aut_keys[i]) return i;
	}
	return n_aut_keys;
}
void for_client(MySocket *sock_){
	try{
		void *tmp1 = sock_;
		void *tmp2 = sock_;
		MySocketPtr sock(sock_);
		//bool authorizated = false;//для проверки, авторизирован ли пользыватель (на этом сокете хоть раз - однозначно проверке на то, что добавлин ли сокет в socketBase)
		//for(int i = 0; i < n_commands; i++) sock << commands[i];
		//for(int i = 0; i < n_answers; i++) sock << answers[i];
		charPtr ptr1, ptr2, ptr3, ptr4;//для логина, пароля, сообщений...
		unsigned short for_cmd;
		while(true){
			sock >> ptr1; //читаем команду
			for_cmd = get_cmd_num(ptr1);
			if(for_cmd == authorization || for_cmd == registration){
				#pragma region TheProgramm
				sock >> ptr1 >> ptr2;
				if (for_cmd == authorization) sock >> ptr3;//так надо
				//проверка длины
				if (ptr1.getLen() > max_login_len || ptr2.getLen() > max_password_len) {
					ptr3.init((char*)nullptr, 0);
					if (ptr1.getLen() > max_login_len) ptr3 = login_len_error;
					if (ptr2.getLen() > max_password_len) ptr3 = ptr3 + password_len_error;
					sock << answers[1] << error + ptr3;
					continue;
				}
				//проверка на запрещенные символы
				if(tabu_chars(ptr1, charPtr("\0", 1)) || tabu_chars(ptr2, charPtr("\0", 1))){
					sock << answers[1] << error + "It is forbidden to use symbols \\0'\" for login or password.";
					continue;
				}
				if (for_cmd == authorization){
					charPtr userID(authorize(ptr1, ptr2));
					if (userID) {
						unsigned short for_key = get_aut_key_num(ptr3);
						if (for_key == n_aut_keys){
							sock << answers[1] << error + key + ptr3 + authorization_key_error;
							continue;
						}
						sock << answers[0];
						if (for_key == check) break;
						UBD *desc = mysql_init(NULL);
						mysql_real_connect(desc, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS);// без флага CLIENT_MULTI_STATEMENTS не получится запускать хранимые процедуры
						#pragma region TheProgramm
						try{
							MYSQL_RES *query_res;
							my_ulonglong n_rows;
							MYSQL_ROW row;
							charPtr ch;
							char *fail_message = nullptr;
							while(true){
								sock >> ptr1;
								init_connection_for_work(desc, userID);
								//init_connection_for_work(desc, userID);
								if (for_key <= get_last_user_tick){
									#pragma region TheProgramm
									///////////////////////////////////////////////////////////////////////////////////////
									if (for_key == sender_private_message || for_key == sender_chat_message){
										sock >> ptr2;//id , message
										//ptr2 = insert_first_bifor_second(ptr2, '\\', '\\');
										if (for_key == sender_private_message) ch.init("P", 1);
										if (for_key == sender_chat_message) ch.init("C", 1);
										if(mysql_query(desc, ("CALL SEND_" + ch + "_M(" + ptr1 + ",'" + mono_to_di_apostrophe(ptr2) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										fail_message = "could not send the message.";
									} else if (for_key == sender_request){
										sock >> ptr2;//userLOGIN , message
										ptr3 = mono_to_di_apostrophe(ptr1);
										if(mysql_query(desc, ("SELECT id FROM my_chat.users WHERE log = '" + ptr3 + "'" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										query_res = mysql_store_result(desc);
										n_rows = mysql_num_rows(query_res);
										mysql_free_result(query_res);
										if (n_rows == 0){ sock << answers[1] << warning + "there is no user with login:\n" + ptr1; continue;}
										else {
											init_connection_for_work(desc, userID);
											if(mysql_query(desc, ("CALL SEND_REQUEST('" + ptr3  +"', '" + mono_to_di_apostrophe(ptr2) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
											fail_message = "user is your friend already.";
										}
									} else if(for_key == accepter_request){
										//sock >> ptr1;//login
										if(mysql_query(desc, ("CALL ACCEPT_REQUEST('" + mono_to_di_apostrophe(ptr1) + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										fail_message = "could not accept the request.";
									} else if(for_key == creater_chat){
										sock >> ptr2;//name_of_chat, DEFAULT
										if (ptr2.getLen() != 1 || (ptr2.getPtr()[0] != 'u' && ptr2.getPtr()[0] != 'g')) throw MyException(1, "could not accept the request.");
										if (ptr1.getLen() > 64){ sock << answers[1] << warning + "maximal length of name for chat is 64."; continue;}
										else {
											if(mysql_query(desc, ("CALL CREATE_CHAT('" + mono_to_di_apostrophe(ptr1) + "', '" + ptr2 + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
											fail_message = "could not accept the request.";
										}
									} else if(for_key == adder_part){
										sock >> ptr2;//friendID , chatID
										if(mysql_query(desc, ("CALL IS_FRIEND_IN_CHAT(" + ptr1 + ", " + ptr2 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										query_res = mysql_store_result(desc);
										n_rows = mysql_num_rows(query_res);
										mysql_free_result(query_res);
										if (n_rows){ sock << answers[1] << warning + "your friend have been in chat allready."; continue;}
										else {
											init_connection_for_work(desc, userID);
											//выполнит ся при условии, что friendID - в друзьях и отправитель в chatID как минимум granted и что friendID не в chatID
											if(mysql_query(desc, ("CALL ADD_PART(" + ptr1 + ", " + ptr2 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
											fail_message = "could not accept the request.";
										}
									} else if(for_key == line){
										//sock >> tmp;
										if(mysql_query(desc, "SELECT unread_private_chats, unread_chats, request FROM my_chat.users WHERE id = @userID") > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										query_res = mysql_store_result(desc);
										row = mysql_fetch_row(query_res);
										sock << answers[0] << row[0] << row[1] << row[2];
										mysql_free_result(query_res);
										if(mysql_query(desc, "UPDATE my_chat.users SET unread_private_chats := FALSE, unread_chats := FALSE, request := FALSE, last_tick := NOW() WHERE id = @userID") > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										continue;
									} else if(for_key == seter_access){
										sock >> ptr2 >> ptr3;//login >> chatID >> acs;
										if(mysql_query(desc, ("CALL SET_ACCESS('" + mono_to_di_apostrophe(ptr1) + "', " + ptr2 + ", '" + ptr3 + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										fail_message = "could not accept the request.";
									} else if(for_key == get_user_data || for_key == get_last_user_tick){
										//sock >> login;
										if (for_key == get_user_data){if(mysql_query(desc, ("SELECT status FROM my_chat.users WHERE log = '" + mono_to_di_apostrophe(ptr1) + "'" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));}
										else if(mysql_query(desc, ("SELECT last_tick FROM my_chat.users WHERE log = '" + mono_to_di_apostrophe(ptr1) + "'" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
										query_res = mysql_store_result(desc);
										n_rows = mysql_num_rows(query_res);
										if (n_rows) sock << answers[0] << mysql_fetch_row(query_res)[0];
										mysql_free_result(query_res);
										if (n_rows == 0){ 
											if (for_key == get_user_data) throw MyException(1, "could not get user data.");
											else throw MyException(1, "could not get last user tick.");
										}
										continue;
									}
									
									if (query_res = mysql_store_result(desc)){
										n_rows = mysql_num_rows(query_res);
										mysql_free_result(query_res);
										if (n_rows) throw MyException(1, fail_message);
										else sock << answers[0];
									}	else sock << answers[0];
									continue;
									///////////////////////////////////////////////////////////////////////////////////////
									#pragma endregion
								}
								#pragma region TheProgramm
								if(for_key == geter_freand_unread_last_tick || for_key == geter_conf_unread_last_tick){
									//вернет ({0; 1}, время последнего сообщения)
									//sock >> ID;
									if (for_key == geter_conf_unread_last_tick) ch = charPtr("c");
									else ch = charPtr("p");
									if(mysql_query(desc, ("CALL GET_UNREAD_LAST_TICK(" + ptr1 + ", '" + ch + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									n_rows = mysql_num_rows(query_res);
									if (n_rows){
										row = mysql_fetch_row(query_res);
										sock << answers[0] << row[0] << row[1];
									}
									else{
										mysql_free_result(query_res);
										throw MyException(1, "could not get unread and last_tick.");
									}
									mysql_free_result(query_res);
									continue;
								}	
								if(for_key == get_friend_id){
									//вернет ({0; 1}, id друга в списке друзей (если у вас нет такого друга, то вернет 0, а если такого пользователя нет - вернет 1 и сообщение об этом))
									//sock >> ID;
									if(mysql_query(desc, ("CALL GET_FRIEND_ID(" + ptr1 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									n_rows = mysql_num_rows(query_res);
									row = mysql_fetch_row(query_res);
									if (n_rows) sock << answers[0] << row[0];
									else{
										mysql_free_result(query_res);
										throw MyException(1, ("User ' " + ptr2 + " ' is not exsists." + null_symbol).getPtr());
									}
									mysql_free_result(query_res);
									continue;
								}	
								sock >> ptr2 >> ptr3;
								ptr3 = insert_first_bifor_second(ptr3, '\\', '_');
								ptr3 = insert_first_bifor_second(ptr3, '\\', '%');
								//ptr3 = insert_first_bifor_second(ptr3, '\\', '\\');
								if(for_key == geter_n_m_partners_from){
									//если все ок - вернет логины участников чата и к каждому из них 1 - (незабанин) или 0 - (забанен)
									//charPtr n, m, chatID; //n - начиная с какого (счет нач с 0), m - сколько
									//charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
									sock >> ptr4;//sock >> n >> m >> like >> chatID;
									if(mysql_query(desc, ("CALL GNM_PART_F_CHAT(" + ptr1 + ", " + ptr2 + ", '" + mono_to_di_apostrophe(ptr3) + "%', " + ptr4 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
									for (int i = 0; i < n_rows; i++){
										row = mysql_fetch_row(query_res);
										sock << di_to_mono_apostrophe((const char*)row[0]);
										if (charPtr((const char*)row[1]) == charPtr("NULL")) sock << "0";
										else sock << "1";
									}
									mysql_free_result(query_res);
								}
								if(for_key == geter_n_m_requests){
									//смотрит приглашения в друзь
									//если все ок - вернет логины и сообщение к каждому из логинов
									//charPtr n, m; //n - начиная с какого (счет нач с 0), m - сколько
									//charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
									//>> n >> m >> like
									if(mysql_query(desc, ("SELECT U.log, M.message FROM my_chat.r" + userID + " AS M, my_chat.users AS U WHERE U.log LIKE '" + mono_to_di_apostrophe(ptr3) + "%' AND U.id = M.user_id ORDER BY M.last_tick DESC LIMIT " + ptr1 + ", " + ptr2 + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
									for (int i = 0; i < n_rows; i++){
										row = mysql_fetch_row(query_res);
										sock << di_to_mono_apostrophe((const char*)row[0]) << di_to_mono_apostrophe((const char*)row[1]);
									}
									mysql_free_result(query_res);
								}
								if(for_key == geter_n_m_messages_p || for_key == geter_n_m_messages_c){
									//читает сообщения из конференции
									//если все ок - вернет количество сообщений, {id сообщения, сообщение, логин отправителя, время}
									//charPtr n, m, ID; //n - начиная с какого (счет нач с 0), m - сколько
									//sock >> n >> m >> ID;
									if (for_key == geter_n_m_messages_c){
										if(mysql_query(desc, ("CALL GNM_MESSAGES_С(" + ptr1 + ", " + ptr2 + ", " + ptr3 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									}
									else if(mysql_query(desc, ("CALL GNM_MESSAGES_P(" + ptr1 + ", " + ptr2 + ", " + ptr3 + ")" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
									for (int i = 0; i < n_rows; i++){
										row = mysql_fetch_row(query_res);
										sock << row[0] << di_to_mono_apostrophe((const char*)row[2]) << di_to_mono_apostrophe((const char*)row[1]) << row[3];
									}
									mysql_free_result(query_res);
								}
								if (for_key == geter_n_m_users){
									//возвращает список пользовтелей, которые не друзья и не делали заявки в друзья данному пользователю
									//если все ок - вернет количество сообщений, {имя пользователя}
									//charPtr n, m, ch; //n - начиная с какого (счет нач с 0), m - сколько
									//charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
									//sock >> n >> m >> like;
									if(mysql_query(desc, ("CALL GNM_USERS(" + ptr1 + ", " + ptr2 + ", '" + mono_to_di_apostrophe(ptr3) + "%')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
									for (int i = 0; i < n_rows; i++) sock << di_to_mono_apostrophe((const char*)mysql_fetch_row(query_res)[0]);
									mysql_free_result(query_res);
								}
								if(for_key == geter_n_m_friens || for_key == geter_n_m_confs){
									//возвращает список конференций или друзей
									//если все ок - вернет количество сообщений, {id чата, имя чата}
									//charPtr n, m, ch; //n - начиная с какого (счет нач с 0), m - сколько
									//charPtr like;//для поиска по имени (будет искать имя, что начинается на значение, что в like)
									//sock >> n >> m >> like;
									if (for_key == geter_n_m_confs) ch = charPtr("c");
									else ch = charPtr("p");
									if(mysql_query(desc, ("CALL GNM_CHATS(" + ptr1 + ", " + ptr2 + ", '" + mono_to_di_apostrophe(ptr3) + "%', '" + ch + "')" + null_symbol).getPtr()) > 0) throw MyException(mysql_errno(desc), mysql_error(desc));
									query_res = mysql_store_result(desc);
									sock << answers[0] << to_string(n_rows = mysql_num_rows(query_res)).c_str();
									for (int i = 0; i < n_rows; i++){
										row = mysql_fetch_row(query_res);
										sock << row[0] << di_to_mono_apostrophe((const char*)row[1]);
									}
									mysql_free_result(query_res);
									//
									//query_res = mysql_store_result(desc);
									//mysql_free_result(query_res);
									//
								}
								#pragma endregion
							}
						} catch(MySocketException) {
							mysql_close(desc); // Закрываем соединение
						} catch(MyException ex) {
							sock << answers[1] << ex.toString().c_str();
							mysql_close(desc); // Закрываем соединение
						}
						#pragma endregion
						return;
					} else sock << answers[1] << error + authorization_error;
				} else {
					if (!existUser(ptr1)) {
						addUser(ptr1, ptr2);
						sock << answers[0];
					} else sock << answers[1] << error + (user + ptr1 + registration_error);
				}
				continue;
				#pragma endregion
			} else {
				sock << answers[1] << error + (ptr1 + unknown_command);
				continue;
			}
		}
	} catch(MyException e) {
		//if (e.getErrorCode() != WSAECONNRESET) throw;
		//cerr << (string)e << endl << '\a';
	}
}

int main(int argc, char *argv[]){
#pragma region Connecting to DATDBASE
	MD = mysql_init(NULL);
	if(MD == nullptr){
		cerr << error << "can not create MYSQL descriptor.\n";
		return 1;
	}
	string port_s;
	if (argc != 5){
		cout << "Enter host:\n"; cin >> Mhost;
		cout << "Enter port:\n"; cin >> port_s;
		cout << "Enter login:\n"; cin >> Muser;
		cout << "Enter password:\n"; cin >> Mpassword;
	} else { Mhost = argv[1]; port_s = argv[2]; Muser = argv[3]; Mpassword = argv[4]; }
	
	try{
		Mport = atoi(port_s.c_str());
		if (atoi(port_s.c_str()) < 0 || (Mport == 0 && port_s != "0")) throw 2;
	}
	catch(...){
		cerr << error << "bad port.\n";
		return 2;
	}
	if( !mysql_real_connect(MD, Mhost.c_str(), Muser.c_str(), Mpassword.c_str(), NULL, Mport, NULL, CLIENT_MULTI_STATEMENTS) ){
		cerr << error << mysql_error(MD) << endl;
		return 3;
	} else {
		if(mysql_query(MD, "USE my_chat") > 0){
			cerr << error << mysql_error(MD) << endl;
			return 4;
		}
		cout << "connected.\n";
	}
#pragma endregion
	try{
		MySocketPtr sock(new MyWinSocket(SOCK_STREAM));
		sock->bind((MySocketAddress*)new MyWinSocketAddress("", 30000));
		sock->listen(SOMAXCONN);
		while (true) CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)for_client, (LPVOID)sock->accept(), NULL, NULL);
	}
	catch(MyException ex){ cerr << ex.toString(); }
	catch(...){
		cerr << error << "server crashed.\n";
		return 10;
	}
	//mysql_close(MD);
	return 0;
}
#pragma endregion

Код, що описуе інтерфейс

AdderFriend.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class AdderFriend : Form
    {
        User u;
        public AdderFriend(User u)
        {
            InitializeComponent();
            this.u = u.copy();
            this.Controls.Add(this.u);
        }

        void add() {
            Waiter w = new Waiter(ref Central.counter[(int)Central.key.sender_request, 0], ref Central.counter[(int)Central.key.sender_request, 1], new method_empty(this.add_));
        }
        void add_(){
            int k = (int)Central.key.sender_request;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.write(u.Name, Central.socks[k]);
            Central.write(richTextBox1.Text, Central.socks[k]);
            if (Central.read(Central.socks[k]) != Central.answers[0])
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            else {
                //Central.searching_panel.Controls.RemoveByKey(u.Name);
                this.Close();
            }
        }

        bool shiftDown;
        delegate void no_params();
        private void richTextBox1_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Shift || e.KeyCode == Keys.ShiftKey) shiftDown = true;
            if (e.KeyCode == Keys.Enter && !shiftDown) { add(); }
        }
        private void richTextBox1_KeyUp(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Shift || e.KeyCode == Keys.ShiftKey) shiftDown = false;
        }
        private void richTextBox1_Leave(object sender, EventArgs e)
        {
            shiftDown = false;
        }
        private void button1_Click(object sender, EventArgs ev)
        {
            add();
        }
    }
}



AdderFriend.Designer.cs
namespace chat_client
{
    partial class AdderFriend
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // richTextBox1
            // 
            this.richTextBox1.Location = new System.Drawing.Point(-1, 139);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.Size = new System.Drawing.Size(205, 96);
            this.richTextBox1.TabIndex = 0;
            this.richTextBox1.Text = "";
            this.richTextBox1.KeyDown += new System.Windows.Forms.KeyEventHandler(this.richTextBox1_KeyDown);
            this.richTextBox1.KeyUp += new System.Windows.Forms.KeyEventHandler(this.richTextBox1_KeyUp);
            this.richTextBox1.Leave += new System.EventHandler(this.richTextBox1_Leave);
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(210, 139);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(95, 96);
            this.button1.TabIndex = 1;
            this.button1.Text = "ADD";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // AdderFriend
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.DarkCyan;
            this.ClientSize = new System.Drawing.Size(310, 240);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.richTextBox1);
            this.Name = "AdderFriend";
            this.Text = "AdderFriend";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.RichTextBox richTextBox1;
        private System.Windows.Forms.Button button1;
    }
}


Button_more.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Button_more : UserControl
    {
        method do_some;
        public Button_more(method do_)
        {
            InitializeComponent();
            do_some = do_;
        }

        private void more_Click(object sender, EventArgs e)
        {
            do_some(sender, e);
        }
    }
}

Button_more.Designer.cs
namespace chat_client
{
    partial class Button_more
    {
        /// <summary> 
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором компонентов

        /// <summary> 
        /// Обязательный метод для поддержки конструктора - не изменяйте 
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            this.more = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // more
            // 
            this.more.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.more.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F);
            this.more.ImeMode = System.Windows.Forms.ImeMode.NoControl;
            this.more.Location = new System.Drawing.Point(0, 1);
            this.more.Name = "more";
            this.more.Size = new System.Drawing.Size(75, 30);
            this.more.TabIndex = 17;
            this.more.Text = "Еще";
            this.more.UseVisualStyleBackColor = true;
            this.more.Click += new System.EventHandler(this.more_Click);
            // 
            // Button_more
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.Transparent;
            this.Controls.Add(this.more);
            this.MaximumSize = new System.Drawing.Size(0, 32);
            this.MinimumSize = new System.Drawing.Size(75, 32);
            this.Name = "Button_more";
            this.Size = new System.Drawing.Size(75, 32);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Button more;
    }
}


Central.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Threading;
using System.Net.Sockets;
using System.Windows.Forms;

namespace chat_client
{
    public static class Central
    {
        public static method delegate_load_more_to = new method(Central.load_more_to);
        [STAThread]
        public static void Main() {
            Init();
            Chat.ShowDialog();
        }
        //чтоб проверять впервые ли запущ прогр.
        static private bool first = true;
        public static void Init() {
            if (first)
            {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                //Application.Run(new Form1());
                first = false;
            }
            Central.closing = false;
            Central.counter = new UInt64[Central.n_keys, 2];
            Central.socks = new Socket[Central.n_keys];
            Central.threads = new List<Thread>();
            Form2 form = new Form2("User params.", "Login", "Password", Central.commands, Central.answers, Central.keys[0]);
            form.ShowDialog();
            if (!form.aut) Environment.Exit(0);

            friends = new ItemList_with_Button_more(delegate_load_more_to, DockStyle.Fill, DockStyle.Bottom);
            friends.Tag = (object)Central.key.geter_n_m_friens;
            conferences = new ItemList_with_Button_more(delegate_load_more_to, DockStyle.Fill, DockStyle.Bottom);
            conferences.Tag = (object)Central.key.geter_n_m_confs;
            searching_panel = new ItemList_with_Button_more(delegate_load_more_to, DockStyle.Fill, DockStyle.Bottom);
            searching_panel.Tag = (object)Central.key.geter_n_m_users;
            requests = new ItemList_with_Button_more(delegate_load_more_to, DockStyle.Fill, DockStyle.Bottom);
            requests.Tag = (object)Central.key.geter_n_m_requests;

            Conference_fields.Conferences = new Dictionary<string, Conference_fields>();
            User_fields.Users = new Dictionary<string, User_fields>();

            Central.log = form.getParam1();
            Central.pass = form.getParam2();

            Chat = new Form1();
            refresh_data();

            Thread online_ = new System.Threading.Thread(new System.Threading.ThreadStart(Central.online));
            Central.threads.Add(online_);
            Thread online_checker_ = new System.Threading.Thread(new System.Threading.ThreadStart(Central.online_checker));
            Central.threads.Add(online_checker_);
            Thread message_loader_ = new System.Threading.Thread(new System.Threading.ThreadStart(Central.message_loader));
            Central.threads.Add(message_loader_);
            online_.Start();
            online_checker_.Start();
            message_loader_.Start();
        }
        public static void Close(){
            if (Central.socks != null)
            {
                Central.closing = true;
                for (int i = 0; i < Central.socks.Length; i++)
                {
                    if (Central.socks[i] != null) Central.socks[i].Close();
                    Central.socks[i] = null;
                }
            }
            if (Central.threads != null)
            {
                foreach (Thread t in Central.threads) { t.Abort(); }
                Central.threads.Clear();
            }
            Central.threads = null;
            Central.socks = null;
            friends.Clear();
            conferences.Clear();
            searching_panel.Clear();
            requests.Clear();
            User_fields.Users.Clear();
            Conference_fields.Conferences.Clear();
        }

        //public static delegate string[] int_parsms_string(int k, int n_read, params string[] s);
        //public static int_parsms_string for_write_and_read = new int_parsms_string(write_and_read);
        ////пишет и читает данны по к-тому сокету в порядке очереди запросов;
        ////n_read - еоличество строк, что надо прочесть
        //public static string[] write_and_read(int k, int n_read, params string[] s) {
        //    while (counter[k, 0] != counter[k, 1]) { System.Threading.Thread.Sleep(5); }
        //    if (socks[k] == null) set_right(k);
        //    ++counter[k, 0];
        //    for (int i = 0; i < s.Length; i++) write(s[i], socks[k]);
        //    string[] res = new string[n_read];
        //    for (int i = 0; i < n_read; i++) res[i] = read(socks[k]);
        //    ++counter[k, 1];
        //    return res;
        //}

        public static void start_dialog(int k)
        {
            while (counter[k, 0] != counter[k, 1]) { System.Threading.Thread.Sleep(5); }
            ++counter[k, 0];
        }
        public static void stop_dialog(int k) { ++counter[k, 1]; }
        
        public const int n_commands = 2, n_answers = 2, n_keys = 21;
        static public string[] commands = { "aut", "reg" }, answers = { "0", "1" }, keys = { "check", "smp", "smc", "sr", "ar", "cc", "ap", "line", "sa", "gud", "glut", "gnmp", "gnmr", "gnmmp", "gnmc", "gnmf", "gnmco", "gnmu", "gful", "gcul", "gfid"};//массив ключей команды авторизации
        public enum key { check, sender_private_message, sender_chat_message, sender_request, accepter_request, creater_chat, adder_part, line, seter_access, get_user_data, get_last_user_tick, geter_n_m_partners_from, geter_n_m_requests, geter_n_m_messages_p, geter_n_m_messages_c, geter_n_m_friens, geter_n_m_confs, geter_n_m_users, geter_freand_unread_last_tick, geter_conf_unread_last_tick, get_friend_id };
        public const ushort max_message_len = 255 * 257;

        
        static public string log, pass;


        public static ItemList_with_Button_more friends, conferences, searching_panel, requests;
        public static void load_more_to(object sender, EventArgs e){
            ItemList_with_Button_more list = (ItemList_with_Button_more)sender;
            int k = (int)list.Tag;
            if (socks[k] == null) set_right(k);
            if (socks[k] == null) Fatal_Error();
            start_dialog(k);
            write("0", Central.socks[k]);
            write((list.get_n_visible_children() - 1 + 10).ToString(), Central.socks[k]);
            write(Chat.textBox1.Text, Central.socks[k]);
            //if (list == conferences || list == friends) Central.write("0", Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                int n = Convert.ToInt32(Central.read(Central.socks[k]));
                if (list == friends) for (int i = 0; i < n; i++) User_fields.getUser_fields(Central.read(Central.socks[k]), Central.read(Central.socks[k]));
                else if (list == conferences)
                    for (int i = 0; i < n; i++)
                    {
                    }
                else {
                    User[] variable = new User[n];
                    if (list == searching_panel) for (int i = n - 1; i >= 0; i--) variable[i] = User_fields.getUser_fields(null, Central.read(Central.socks[k])).getUser();
                    else if (list == requests){
                        for (int i = n - 1; i >= 0; i--){
                            variable[i] = User_fields.getUser_fields(null, Central.read(Central.socks[k])).getUser();
                            variable[i].Tag = Central.read(Central.socks[k]);
                        }
                    }
                    list.Clear();
                    list.Controls.AddRange(variable);
                }
            }
            else{
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            stop_dialog(k);
        }
        public static void refresh_data()
        {
            //this.Controls.SetChildIndex - испозьзовать!
            Central.no_selected();
            load_accaunt_data();
            Central.load_more_to(Central.friends, null);
            Central.load_more_to(Central.conferences, null);
        }
        public static string get_user_status(string name)
        {
            int k = (int)Central.key.get_user_data;
            Waiter w = new Waiter(ref Central.counter[k, 0], ref Central.counter[k, 1], new method_obj1(Central.get_user_status_), name);
            return (string)w.res;
        }
        public static object get_user_status_(object name)
        {
            int k = (int)Central.key.get_user_data;
            if (Central.socks[k] == null) Central.socks[k] = Central.make_authorised_sock(k);
            if (Central.socks[k] == null) return null;
            Central.write((string)name, Central.socks[k]);
            return Central.read(Central.socks[k]);
        }
        //для развития программы (авки загрузить,если сделаю)
        public static void load_accaunt_data() { }

        public static void no_selected()
        {
            Central.selected_num = 0;
            Central.selected_obj = null;
            Chat.panel6.Controls.Clear();
            Chat.panel7.Enabled = false;
        }
        public static void ShowMessages(User_fields user)
        {
            if (user.ID != null){
                bool exec = false;
                if (selected_num != 1) exec = true;
                else if(user.Name != ((User_fields)selected_obj).Name) exec = true;
                if (exec) {
                    selected_obj = user;
                    selected_num = 1;
                    Chat.panel6.Controls.Clear();
                    Chat.panel6.Controls.Add(user.messages);
                    Chat.panel6.Controls.Add(user.getUser());
                    if (user.messages.Controls.Count <= 1) { user.load_more_messages(); }//сделать!
                    Chat.panel7.Enabled = true;
                }

            }
            else no_selected();
        }
        public static void ShowMessages(Conference_fields conf)
        {
            if (conf.ID != null){
                bool exec = false;
                if (selected_num != 2) exec = true;
                else if(conf.ID != ((Conference_fields)selected_obj).ID) exec = true;
                if (exec) {
                    selected_obj = conf;
                    selected_num = 2;
                    Chat.panel6.Controls.Clear();
                    Chat.panel6.Controls.Add(conf.messages);
                    Chat.panel6.Controls.Add(conf.getConference());
                    if (conf.messages.Controls.Count <= 1) { conf.load_more_messages(); }//сделать!
                    Chat.panel7.Enabled = true;
                }
            }
            else no_selected();
        }

        public static void insert_friend(User_fields fields) {
            if (fields.ID != null)
            {
                if (!friends.Controls.ContainsKey(fields.Name))
                {
                    User u = fields.getUser();
                    friends.Controls.Add(u);
                    u.Last_tickChanged();//чтоб поставить на нужное место
                    u.ContextMenuStrip = Chat.contextMenuStrip1FRIEND;
                    requests.Controls.RemoveByKey(fields.Name);
                    searching_panel.Controls.RemoveByKey(fields.Name);
                }
            }
        }
        public static void insert_conference(Conference_fields fields) {
            if (!conferences.Controls.ContainsKey(fields.Name))
            {
                Conference c = fields.getConference();
                conferences.Controls.Add(c);
                c.Last_tickChanged();//чтоб поставить на нужное место
            }
        }

        static public Form1 Chat;
        static public Socket[] socks;
        public static List<System.Threading.Thread> threads = new List<System.Threading.Thread>();
        public static Thread send_mess_in_new_thread;
        //для выполнения взятия результата в нужном порядке
        static public UInt64[,] counter;

        
        static public bool closing;//хранит значение true, если сейчас должен произойти разрыв связи с сервером.(чтоб эксепшн не вылетал)

        
        //востанавливает сокет под номером k
        public static void set_right(int k){
            socks[k] = make_authorised_sock(k);
        }
        public static Socket make_authorised_sock(int k)
        {
            Socket sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            connect(sock);
            write(commands[0], sock);
            write(log, sock);
            write(pass, sock);
            write(keys[(int)k], sock);
            if (read(sock) != answers[0])
            {
                MessageBox.Show(read(sock), "Message from server.");
                return null;
            }
            return sock;
        }

        public static int still_online = 2;//количество минут
        public static void online_checker(){
            Thread.Sleep(200);
            int k = (int)Central.key.get_last_user_tick;
            DateTime now = new DateTime();
            while(true){
                Central.start_dialog(k);
                if (Central.socks[k] == null) Central.set_right(k);
                if (Central.socks[k] == null) Central.Fatal_Error();
                Central.write(Central.log, Central.socks[k]);
                if (Central.read(Central.socks[k]) == Central.answers[0]) now = DateTime.Parse(Central.read(Central.socks[k]));
                else{
                    MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                    Central.socks[k].Close();
                    Central.set_right(k);
                    Central.stop_dialog(k);
                    Thread.Sleep(100000);//100 sec
                    continue;
                }
                Central.stop_dialog(k);
                var ref_ = User_fields.Users.Values.GetEnumerator();
                ref_.MoveNext();
                int count = User_fields.Users.Values.Count;
                try { for (int i = 0; i < count; i++, ref_.MoveNext()) { ref_.Current.online_checker(now, still_online); } }
                catch (Exception) {}
                Thread.Sleep(100000);//100 sec
            }
        }

        //отсылает сообщение текущему собеседнику
        public static void send_mess(string mess)
        {
            int k = 0;
            string ID = "";
            if (mess == "" || selected_obj != null && (selected_num == 1 || selected_num == 2))
            {
                if (Central.selected_num == 1)
                {
                    k = (int)Central.key.sender_private_message;
                    ID = ((User_fields)selected_obj).ID;
                }
                else if (Central.selected_num == 2)
                {
                    k = (int)Central.key.sender_chat_message;
                    ID = ((Conference_fields)selected_obj).ID;
                }
            }
            else { return; }

            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write(ID, Central.socks[k]);
            Central.write(mess, Central.socks[k]);
            if (Central.read(Central.socks[k]) != Central.answers[0])
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }
        public static void send_mess(object mess)
        {
            send_mess((string)mess);
        }

        public static void there_is_unreed_user()
        {
            var ref_ = User_fields.Users.Values.GetEnumerator();
            ref_.MoveNext();
            int count = User_fields.Users.Values.Count;
            try { for (int i = 0; i < count; i++, ref_.MoveNext()) { ref_.Current.unread_and_last_tick_checker(); } }
            catch (Exception) { }
        }
        public static void there_is_anreed_conference()
        {
            var ref_ = Conference_fields.Conferences.Values.GetEnumerator();
            ref_.MoveNext();
            int count = Conference_fields.Conferences.Values.Count;
            try { for (int i = 0; i < count; i++, ref_.MoveNext()) { ref_.Current.unread_and_last_tick_checker(); } }
            catch (Exception) { }
        }
        public static void there_is_anreed_request()
        {
            load_more_to(requests, null);
        }

        public static void online()
        {
            Thread.Sleep(200);
            int k = (int)Central.key.line;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            while (true)
            {
                Central.write("", Central.socks[k]);
                if (Central.read(Central.socks[k]) == Central.answers[0])
                {
                    if (Central.read(Central.socks[k]) == "1") Chat.panel6.BeginInvoke(new method_empty(there_is_unreed_user));
                    if (Central.read(Central.socks[k]) == "1") Chat.panel6.BeginInvoke(new method_empty(there_is_anreed_conference));
                    if (Central.read(Central.socks[k]) == "1") Chat.panel6.BeginInvoke(new method_empty(there_is_anreed_request));
                }
                else
                {
                    MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                    Central.socks[k].Close();
                    Central.set_right(k);
                }
                Thread.Sleep(500);
            }
        }

        delegate void method_one_obj_param(object obj);
        delegate void method_two_obj_param(object obj1, object obj2);
        delegate void method_four_obj_param(object obj1, object obj2, object obj3, object obj4);
        public static void User_fields_set_Unread(object fields, object bool_var)
        {
            ((User_fields)fields).Unread = (bool)bool_var;
        }
        public static void Conference_fields_set_Unread(object fields, object bool_var)
        {
            ((Conference_fields)fields).Unread = (bool)bool_var;
        }
        public static void message_loader() {
            int k = (int)Central.key.geter_n_m_messages_p;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            k = (int)Central.key.geter_n_m_messages_c;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            string ID = null;
            int n_messages = 2; //количество сообщени которые можно читать одним блоком
            ItemList_with_Button_more messages = null;
            object selected = null;
            method_two_obj_param User_fields_set_Unread_delegate = new method_two_obj_param(User_fields_set_Unread);
            method_two_obj_param Conference_fields_set_Unread_delegate = new method_two_obj_param(Conference_fields_set_Unread);

            while (true)
            {
                Thread.Sleep(100);
                if (selected_num == 0 || selected_obj == null) continue;
                selected = selected_obj;
                if (selected_num == 1){
                    k = (int)Central.key.geter_n_m_messages_p;
                    messages = ((User_fields)selected).messages;
                    ID = ((User_fields)selected).ID;
                }
                else if (selected_num == 2){
                    k = (int)Central.key.geter_n_m_messages_c;
                    messages = ((Conference_fields)selected).messages;
                    ID = ((Conference_fields)selected).ID;
                }
                Central.start_dialog(k);
                bool enought = false;
                int numb = 0;
                while (!enought){
                    Central.write((numb).ToString(), Central.socks[k]);
                    Central.write((numb = numb + n_messages).ToString(), Central.socks[k]);
                    Central.write(ID, Central.socks[k]);
                    if (Central.read(Central.socks[k]) == Central.answers[0])
                    {
                        int n = Convert.ToInt32(Central.read(Central.socks[k]));
                        Message[] messages_ = new Message[n];
                        string message_ID, message, login, time;
                        for (int i = 0; i < n; i++)
                        {
                            message_ID = Central.read(Central.socks[k]);
                            message = Central.read(Central.socks[k]);
                            login = Central.read(Central.socks[k]);
                            time = Central.read(Central.socks[k]);
                            if (!messages.Controls.ContainsKey(message_ID)){
                                if (k == (int)Central.key.geter_n_m_messages_p) Chat.BeginInvoke(new method_four_obj_param(((User_fields)selected).insert_message), message_ID, time, message, login);
                                else if (k == (int)Central.key.geter_n_m_messages_c) Chat.BeginInvoke(new method_four_obj_param(((Conference_fields)selected).insert_message), message_ID, time, message, login);
                            }
                            else {
                                i++;
                                for (; i < n; i++){
                                    Central.read(Central.socks[k]);
                                    Central.read(Central.socks[k]);
                                    Central.read(Central.socks[k]);
                                    Central.read(Central.socks[k]);
                                }
                                enought = true;
                                break;
                            }
                        }
                        if (n < n_messages) enought = true;
                    }
                    else
                    {
                        MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                        Central.socks[k].Close();
                        Central.set_right(k);
                    }
                }
                Central.stop_dialog(k);
                if (k == (int)Central.key.geter_n_m_messages_p) Chat.BeginInvoke(User_fields_set_Unread_delegate, selected, false);
                else if (k == (int)Central.key.geter_n_m_messages_c) Chat.BeginInvoke(Conference_fields_set_Unread_delegate, selected, false);
            }
        }
        
        public static object selected_obj;
        public static int selected_num = 0; //0 - nothing, 1 - User_fields, 2 - Conference_fields

        public static void Fatal_Error(string s)
        {
            MessageBox.Show(s, "ERROR.");
            Environment.Exit(1);
        }
        public static void Fatal_Error()
        {
            Fatal_Error("Программа не может работать.");
        }


        public static void write(string s, Socket sock)
        {
            try
            {
                write(Encoding.UTF8.GetBytes(s), sock);
            }
            catch (Exception ex) {
                if (!closing)
                {
                    MessageBox.Show(ex.ToString(), "ERROR.");
                    Environment.Exit(4);
                }
            }
        }
        public static void write(byte[] buf, Socket sock)
        {
            if (buf.Length > max_message_len) throw new Exception("Could not send so long message.\nYour message weighs " + buf.Length.ToString() + " bytes, which is greater than the maximum value " + max_message_len.ToString() + ".");
            byte[] len = { (byte)(buf.Length / 256), (byte)(buf.Length % 256) };
            try
            {
                sock.Send(len, 2, SocketFlags.None);
                if (buf.Length != 0) sock.Send(buf, buf.Length, SocketFlags.None);
            }
            catch (Exception) {
                if (!closing) throw;
            }
        }
        public static string read(Socket sock)
        {
            try
            {
                return Encoding.UTF8.GetString(readBytes(sock));
            }
            catch (Exception ex) {
                if (!closing) {
                    MessageBox.Show(ex.ToString(), "ERROR.");
                    Environment.Exit(5);
                }
                return null;
            }
        }
        public static byte[] readBytes(Socket sock)
        {
            byte[] buf = new byte[2];
            try
            {
                sock.Receive(buf, 2, SocketFlags.None);
                buf = new byte[buf[0] * 256 + buf[1]];
                if (buf.Length != 0) sock.Receive(buf, buf.Length, SocketFlags.None);
                return buf;
            }
            catch (Exception) {
                throw;
            }
        }
        ////////////////////////////////////////////////////////////////
        //для ip, port
        const string IPEnvironmentVariable = "IP_of_chat_server";
        const string PortEnvironmentVariable = "Port_of_chat_server";
        public static void connect(Socket sock)
        {
            string ip = Environment.GetEnvironmentVariable(IPEnvironmentVariable);
            if (ip == null)
            {
                MessageBox.Show("Could not get environment variable \"" + IPEnvironmentVariable + "\".", "ERROR.");
                Environment.Exit(1);
            }
            string port = Environment.GetEnvironmentVariable(PortEnvironmentVariable);
            if (port == null)
            {
                MessageBox.Show("Could not get environment variable \"" + PortEnvironmentVariable + "\".", "ERROR.");
                Environment.Exit(2);
            }
            try
            {
                sock.Connect(ip, Convert.ToUInt16(port));
            }
            catch (Exception e)
            {
                MessageBox.Show(e.ToString(), "ERROR.");
                Environment.Exit(3);
            }
        }
    }
}

Conference.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Conference : UserControl{

        public Conference_fields fields;

        public bool Unread{
            get {
                if (panel1.BackColor == SystemColors.ControlLight) return false;
                else return true;
            }
            set {
                if (value) panel1.BackColor = SystemColors.ControlDark;
                else panel1.BackColor = SystemColors.ControlLight;
            }
        }
        
        public Conference(string id, string name, ContextMenuStrip contextMenuStrip){
            InitializeComponent();
            this.Dock = DockStyle.Top;
            this.fields = Conference_fields.getConference_fields(id, name);
            this.ContextMenuStrip = contextMenuStrip;
            this.Unread = this.fields.Unread;
            this.Name = this.fields.ID;
            this.name.Text = this.fields.Name;
            this.fields.UnreadChanged.Add(new method_empty(this.UnreadChanged));
            this.fields.Last_tickChanged.Add(new method_empty(this.Last_tickChanged));
        }

        public virtual Conference copy() {
            return new Conference(fields.ID, fields.Name, this.ContextMenuStrip);
        }

        protected virtual void Contact_Click(object sender, EventArgs e){
            Central.ShowMessages(this.fields);
        }
        public void UnreadChanged() {
            this.Unread = fields.Unread;
        }
        public void Last_tickChanged(){
            if (this.Parent != null)
            {
                int n = this.Parent.Controls.Count;
                DateTime this_last_tick = DateTime.Parse(this.fields.Last_tick);
                for (int i = 0; i < n; i++)
                {
                    try
                    {
                        Conference C = (Conference)this.Parent.Controls[i];
                        if (DateTime.Parse(C.fields.Last_tick) >= this_last_tick)
                        {
                            this.Parent.Controls.SetChildIndex(this, i);
                            break;
                        }
                    }
                    catch (Exception) { }
                }
            }
        }
    }
}

Conference.Designer.cs
namespace chat_client
{
    partial class Conference
    {
        /// <summary> 
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором компонентов

        /// <summary> 
        /// Обязательный метод для поддержки конструктора - не изменяйте 
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        protected void InitializeComponent()
        {
            this.panel1 = new System.Windows.Forms.Panel();
            this.name = new System.Windows.Forms.Label();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.BackColor = System.Drawing.SystemColors.ControlLight;
            this.panel1.Controls.Add(this.name);
            this.panel1.Location = new System.Drawing.Point(0, 1);
            this.panel1.MinimumSize = new System.Drawing.Size(35, 15);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(35, 15);
            this.panel1.TabIndex = 20;
            this.panel1.Click += new System.EventHandler(this.Contact_Click);
            // 
            // name
            // 
            this.name.AutoEllipsis = true;
            this.name.Font = new System.Drawing.Font("Microsoft Sans Serif", 9F);
            this.name.ForeColor = System.Drawing.SystemColors.HotTrack;
            this.name.ImeMode = System.Windows.Forms.ImeMode.NoControl;
            this.name.Location = new System.Drawing.Point(0, 0);
            this.name.MaximumSize = new System.Drawing.Size(0, 15);
            this.name.MinimumSize = new System.Drawing.Size(35, 15);
            this.name.Name = "name";
            this.name.Size = new System.Drawing.Size(35, 15);
            this.name.TabIndex = 20;
            this.name.Text = "имя";
            this.name.Click += new System.EventHandler(this.Contact_Click);
            // 
            // Conference
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.Transparent;
            this.Controls.Add(this.panel1);
            this.MaximumSize = new System.Drawing.Size(0, 17);
            this.MinimumSize = new System.Drawing.Size(35, 17);
            this.Name = "Conference";
            this.Size = new System.Drawing.Size(35, 17);
            this.Click += new System.EventHandler(this.Contact_Click);
            this.panel1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        protected System.Windows.Forms.Panel panel1;
        public System.Windows.Forms.Label name;


    }
}


Conference_fields.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Threading;

namespace chat_client
{
    delegate void Conference_fields_delegate(Conference_fields sender);
    public class Conference_fields
    {

        public static Dictionary<string, Conference_fields> Conferences;//id contact для конфере
        public static Conference_fields getConference_fields(string id){
            if (Conferences.ContainsKey(id)) return Conferences[id];
            else return null;
        }
        public static Conference_fields getConference_fields(string id, string name)
        {
            if (Conferences.ContainsKey(id)){
                Conferences[id].Name = name;
                return Conferences[id];
            }
            Conference_fields res = (Conferences[id] = new Conference_fields(id, name));
            Central.insert_conference(res);
            return res;
        }


        private bool unread;
        private string last_tick, name, id;
        public ItemList_with_Button_more messages, partners;
        public List<method_empty> UnreadChanged, Last_tickChanged;

        private Conference_fields(string id, string name)
        {
            UnreadChanged = new List<method_empty>();
            Last_tickChanged = new List<method_empty>();

            this.id = id;
            this.name = name;

            messages = new ItemList_with_Button_more(new method(this.load_more_messages), DockStyle.Fill, DockStyle.Top);
            messages.AutoScroll = true;
            partners = new ItemList_with_Button_more(new method(this.load_more_partners), DockStyle.Fill, DockStyle.Top);
            partners.AutoScroll = true;

            unread_and_last_tick_checker();
        }
        public Conference getConference()
        {
            return new Conference(this.ID, this.Name, Central.Chat.contextMenuStrip2CONFER);
        }

        public void unread_and_last_tick_checker()
        {
            int k = (int)Central.key.geter_conf_unread_last_tick;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write(this.ID, Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                this.Unread = Convert.ToBoolean(Convert.ToInt16(Central.read(Central.socks[k])));
                this.Last_tick = Central.read(Central.socks[k]);
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }
        private void run_listeners(List<method_empty> methodsList){
            int n = methodsList.Count;
            for (int i = 0; i < n; i++)
            {
                try { methodsList[i](); }
                catch (Exception e)
                {
                    MessageBox.Show(e.ToString(), "Error.");
                }
            }
        }
        
        public bool Unread{
            get { return unread; }
            set
            {
                if (value != unread) {
                    unread = value;
                    run_listeners(UnreadChanged);
                }
            }
        }
        public string Last_tick{
            get { return last_tick; }
            set {
                if (value != last_tick) {
                    last_tick = value;
                    run_listeners(Last_tickChanged);
                }
            }
        }

        public string Name{
            get { return name; }
            private set {
                if (name != value) name = value;
            }
        }
        public string ID{
            get { return id; }
        }

        //для вызова из двугого потока с использованием инвок
        public void insert_message(object message_ID, object time, object message, object login)
        {
            insert_message((string)message_ID, (string)time, (string)message, (string)login);
        }
        public void insert_message(object m) { insert_message((Message)m); }
        //при использовании этой перегрузки метода не приходится создавать лишних слушателей событий
        public void insert_message(string message_ID, string time, string message, string login)
        {
            if (!messages.Controls.ContainsKey(message_ID)) insert_message(new Message((string)message_ID, (string)time, (string)message, User.getUser((string)login)));
        }
        public void insert_message(Message m)
        {
            if (!messages.Controls.ContainsKey(m.Name))
            {
                messages.Controls.Add(m);
                if (messages.Controls.Count > 2)
                {
                    DateTime time_of_message = new DateTime();
                    time_of_message = DateTime.Parse(m.time.Text);
                    foreach (object obj_ in messages.Controls)
                    {
                        try
                        {
                            Message obj = (Message)obj_;
                            if (DateTime.Parse(obj.time.Text) >= time_of_message)
                            {
                                messages.Controls.SetChildIndex(m, messages.Controls.IndexOf(obj));
                                if (messages.Controls.IndexOf(m) == messages.Controls.Count - 1) messages.VerticalScroll.Value = messages.VerticalScroll.Maximum;
                                break;
                            }
                        }
                        catch (Exception) { }
                    }
                }
            }
        }
        public void load_more_messages()
        {
            int k = (int)Central.key.geter_n_m_messages_p;

            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write((messages.Controls.Count - 1).ToString(), Central.socks[k]);
            Central.write((messages.Controls.Count - 1 + 10).ToString(), Central.socks[k]);
            Central.write(ID, Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                int n = Convert.ToInt32(Central.read(Central.socks[k]));
                Message[] messages_ = new Message[n];
                User messager;
                string message_ID, message, login, time;
                for (int i = 0; i < n; i++)
                {
                    message_ID = Central.read(Central.socks[k]);
                    message = Central.read(Central.socks[k]);
                    login = Central.read(Central.socks[k]);
                    time = Central.read(Central.socks[k]);
                    messager = User.getUser(login);
                    this.insert_message(new Message(message_ID, time, message, messager));
                }
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }
        private void load_more_messages(object sender, EventArgs e)
        {
            load_more_messages();
        }
        public void load_more_partners(object sender, EventArgs e) {
        }
    }
}


Form1.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace chat_client
{
    public delegate void method(object sender, EventArgs e);
    public delegate void method_empty();
    public partial class Form1 : Form
    {   
#region _._._._.Готово
        ////////////////////////////////////////////////////////////////
        
        
        ////////////////////////////////////////////////////////////////
        //для управления расположения панелей на форме
        int x;
        private void panel11_MouseDown(object sender, MouseEventArgs e)
        {
            x = e.X;
        }
        private void panel11_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left && e.X != x)
            {
                if ((panel11.Location.X + e.X - x >= menuStrip1.Size.Width / 4) && ((panel11.Location.X + e.X - x) + panel11.Size.Width <= (menuStrip1.Size.Width * 4) / 10))
                    panel11.Location = new Point(panel11.Location.X + e.X - x, panel11.Location.Y);
                else
                {
                    if (panel11.Location.X + e.X - x < menuStrip1.Size.Width / 4)
                        panel11.Location = new Point(menuStrip1.Size.Width / 4, panel11.Location.Y);
                    else
                        panel11.Location = new Point((menuStrip1.Size.Width * 4) / 10 - panel11.Size.Width, panel11.Location.Y);
                }
            }
        }
        private void panel11_Move(object sender, EventArgs e)
        {
            panel1.Size = new Size(panel11.Location.X, panel1.Size.Height);
            panel2.Size = new Size(menuStrip1.Size.Width - (panel11.Location.X + panel11.Size.Width), panel2.Size.Height);
            panel2.Location = new Point(panel11.Location.X + panel11.Size.Width, menuStrip1.Size.Height);
        }

        ////////////////////////////////////////////////////////////////
        private void toolStripMenuItem5_Click(object sender, EventArgs e){
            this.Close();
            this.Dispose();
            Central.Main();
        }
        ////////////////////////////////////////////////////////////////
        //управление воодом сообщения
        bool shiftDown;
        delegate void no_params();
        private void richTextBox2_KeyDown(object sender, KeyEventArgs e){
            if (e.KeyCode == Keys.Shift || e.KeyCode == Keys.ShiftKey) shiftDown = true;
            if (e.KeyCode == Keys.Enter && !shiftDown) {
                (new System.Threading.Thread(new ParameterizedThreadStart(Central.send_mess))).Start(this.richTextBox2.Text);
                (new System.Threading.Thread(delegate() { this.BeginInvoke(new no_params(richTextBox2.Clear)); })).Start();
            }
        }
        private void richTextBox2_KeyUp(object sender, KeyEventArgs e){
            if (e.KeyCode == Keys.Shift || e.KeyCode == Keys.ShiftKey) shiftDown = false;
        }
        private void richTextBox2_Leave(object sender, EventArgs e){
            shiftDown = false;
        }
        private void button1_Click(object sender, EventArgs ev){
            Central.send_mess(this.richTextBox2.Text);
        }
        ////////////////////////////////////////////////////////////////
        private void toolStripMenuItem6_Click(object sender, EventArgs e){
            Central.refresh_data();
        }
        ////////////////////////////////////////////////////////////////
        private void textBox1_TextChanged(object sender, EventArgs e)
        {
            search();
        }
        private void textBox1_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == '\r') search();
        }
        private void button2_Click(object sender, EventArgs e)
        {
            textBox1.Text = "";
        }
        private void button9_Click(object sender, EventArgs e)
        {
            search();
        }
        private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
        {
            foreach (Control obj in panel5.Controls) { if (obj.Dock != DockStyle.Top) panel5.Controls.Remove(obj); }
            panel5.Controls.Add((Control)tabControl1.SelectedTab.Tag);
            Central.load_more_to(tabControl1.SelectedTab.Tag, null);
        }
        void search()
        {
            //ItemList_with_Button_more list = (ItemList_with_Button_more)tabControl1.SelectedTab.Tag;
            //list.Clear();
            Central.load_more_to(tabControl1.SelectedTab.Tag, null);
        }
        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////

        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            Central.Close();
        }

        private void toolStripMenuItem1_Click(object sender, EventArgs e)
        {
            User u = (User)((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl;
            Label label = new Label();
            label.Text = "\n\nStatus:\n" + Central.get_user_status(u.Name);
            Form3 form = new Form3(u, label);
            form.ShowDialog();
        }

        private void toolStripMenuItem11_Click(object sender, EventArgs e)
        {
            User u = (User)((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl;
            Label label = new Label();
            label.Text = "\n\nStatus:\n" + Central.get_user_status(u.Name);
            if (u.Tag != null) label.Text += "\n\nMessage:\n" + (string)u.Tag;
            Form3 form = new Form3(u, label);
            form.ShowDialog();
        }

        private void toolStripMenuItem2_Click(object sender, EventArgs e)
        {
            Conference c = (Conference)((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl;
            Form3 form = new Form3(c, c.fields.partners);
            form.ShowDialog();
        }

        private void перепискаToolStripMenuItem_Click(object sender, EventArgs e)
        {
            try { Central.ShowMessages(User_fields.Users[((User)(((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl)).Name]); }
            catch(Exception) { Central.ShowMessages(User_fields.Users[((Conference)(((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl)).Name]); }
        }

        private void toolStripMenuItem9_Click(object sender, EventArgs e)
        {
            try { Central.ShowMessages(User_fields.Users[((User)(((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl)).Name]); }
            catch (Exception) { Central.ShowMessages(User_fields.Users[((Conference)(((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl)).Name]); }
        }

        private void toolStripMenuItem13_Click(object sender, EventArgs e)
        {
            User u = (User)((ContextMenuStrip)(((ToolStripMenuItem)sender).GetCurrentParent())).SourceControl;
            if (!Central.requests.Controls.Contains(u))
            {
                AdderFriend form = new AdderFriend(u);
                form.Show();
            }
            else accept(u);
        }

        void accept(User u)
        {
            Waiter w = new Waiter(ref Central.counter[(int)Central.key.accepter_request, 0], ref Central.counter[(int)Central.key.accepter_request, 1], new method_obj1(this.accept_), u);
        }
        object accept_(object u_)
        {
            User u = (User)u_;
            int k = (int)Central.key.accepter_request;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.write(u.Name, Central.socks[k]);
            if (Central.read(Central.socks[k]) != Central.answers[0])
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.requests.Controls.RemoveByKey(u.Name);
            Central.searching_panel.Controls.RemoveByKey(u.Name);
            return null;
        }
#endregion

        public Form1(){

            InitializeComponent();

            this.Text += ": " + Central.log;

            tabPage1.Tag = Central.friends;
            tabPage2.Tag = Central.conferences;
            tabPage3.Tag = Central.searching_panel;
            tabPage4.Tag = Central.requests;

            this.panel5.Controls.Add(Central.friends);
        }

    }
}


Form1.Designer.cs

namespace chat_client
{
    partial class Form1
    {
        /// <summary>
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором форм Windows

        /// <summary>
        /// Обязательный метод для поддержки конструктора - не изменяйте
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Form1));
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.toolStripMenuItem4 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem5 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem6 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem7 = new System.Windows.Forms.ToolStripMenuItem();
            this.аккаунтToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel5 = new System.Windows.Forms.Panel();
            this.panel3 = new System.Windows.Forms.Panel();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.button2 = new System.Windows.Forms.Button();
            this.button9 = new System.Windows.Forms.Button();
            this.panel2 = new System.Windows.Forms.Panel();
            this.panel6 = new System.Windows.Forms.Panel();
            this.panel7 = new System.Windows.Forms.Panel();
            this.richTextBox2 = new System.Windows.Forms.RichTextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.panel11 = new System.Windows.Forms.Panel();
            this.panel4 = new System.Windows.Forms.Panel();
            this.contextMenuStrip1FRIEND = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
            this.перепискаToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.contextMenuStrip2CONFER = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem9 = new System.Windows.Forms.ToolStripMenuItem();
            this.contextMenuStrip3USERS = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.toolStripMenuItem11 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem13 = new System.Windows.Forms.ToolStripMenuItem();
            this.tabPage4 = new System.Windows.Forms.TabPage();
            this.tabPage3 = new System.Windows.Forms.TabPage();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.menuStrip1.SuspendLayout();
            this.panel1.SuspendLayout();
            this.panel3.SuspendLayout();
            this.panel2.SuspendLayout();
            this.panel7.SuspendLayout();
            this.panel11.SuspendLayout();
            this.contextMenuStrip1FRIEND.SuspendLayout();
            this.contextMenuStrip2CONFER.SuspendLayout();
            this.contextMenuStrip3USERS.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem4});
            resources.ApplyResources(this.menuStrip1, "menuStrip1");
            this.menuStrip1.Name = "menuStrip1";
            // 
            // toolStripMenuItem4
            // 
            this.toolStripMenuItem4.BackColor = System.Drawing.Color.DarkCyan;
            this.toolStripMenuItem4.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem5,
            this.toolStripMenuItem6,
            this.toolStripMenuItem7,
            this.аккаунтToolStripMenuItem});
            this.toolStripMenuItem4.Name = "toolStripMenuItem4";
            resources.ApplyResources(this.toolStripMenuItem4, "toolStripMenuItem4");
            // 
            // toolStripMenuItem5
            // 
            this.toolStripMenuItem5.Name = "toolStripMenuItem5";
            resources.ApplyResources(this.toolStripMenuItem5, "toolStripMenuItem5");
            this.toolStripMenuItem5.Click += new System.EventHandler(this.toolStripMenuItem5_Click);
            // 
            // toolStripMenuItem6
            // 
            this.toolStripMenuItem6.Name = "toolStripMenuItem6";
            resources.ApplyResources(this.toolStripMenuItem6, "toolStripMenuItem6");
            this.toolStripMenuItem6.Click += new System.EventHandler(this.toolStripMenuItem6_Click);
            // 
            // toolStripMenuItem7
            // 
            this.toolStripMenuItem7.Name = "toolStripMenuItem7";
            resources.ApplyResources(this.toolStripMenuItem7, "toolStripMenuItem7");
            // 
            // аккаунтToolStripMenuItem
            // 
            this.аккаунтToolStripMenuItem.Name = "аккаунтToolStripMenuItem";
            resources.ApplyResources(this.аккаунтToolStripMenuItem, "аккаунтToolStripMenuItem");
            // 
            // panel1
            // 
            this.panel1.BackColor = System.Drawing.Color.Transparent;
            this.panel1.Controls.Add(this.panel5);
            this.panel1.Controls.Add(this.tabControl1);
            this.panel1.Controls.Add(this.panel3);
            resources.ApplyResources(this.panel1, "panel1");
            this.panel1.Name = "panel1";
            // 
            // panel5
            // 
            resources.ApplyResources(this.panel5, "panel5");
            this.panel5.Name = "panel5";
            // 
            // panel3
            // 
            this.panel3.Controls.Add(this.textBox1);
            this.panel3.Controls.Add(this.button2);
            this.panel3.Controls.Add(this.button9);
            resources.ApplyResources(this.panel3, "panel3");
            this.panel3.Name = "panel3";
            // 
            // textBox1
            // 
            resources.ApplyResources(this.textBox1, "textBox1");
            this.textBox1.Name = "textBox1";
            this.textBox1.TextChanged += new System.EventHandler(this.textBox1_TextChanged);
            this.textBox1.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.textBox1_KeyPress);
            // 
            // button2
            // 
            resources.ApplyResources(this.button2, "button2");
            this.button2.Image = global::chat_client.Properties.Resources.крестик;
            this.button2.Name = "button2";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // button9
            // 
            resources.ApplyResources(this.button9, "button9");
            this.button9.Image = global::chat_client.Properties.Resources.лупа3;
            this.button9.Name = "button9";
            this.button9.UseVisualStyleBackColor = true;
            this.button9.Click += new System.EventHandler(this.button9_Click);
            // 
            // panel2
            // 
            resources.ApplyResources(this.panel2, "panel2");
            this.panel2.BackColor = System.Drawing.Color.Transparent;
            this.panel2.Controls.Add(this.panel6);
            this.panel2.Controls.Add(this.panel7);
            this.panel2.Name = "panel2";
            // 
            // panel6
            // 
            resources.ApplyResources(this.panel6, "panel6");
            this.panel6.Name = "panel6";
            // 
            // panel7
            // 
            this.panel7.Controls.Add(this.richTextBox2);
            this.panel7.Controls.Add(this.button1);
            resources.ApplyResources(this.panel7, "panel7");
            this.panel7.Name = "panel7";
            // 
            // richTextBox2
            // 
            this.richTextBox2.BackColor = System.Drawing.SystemColors.Window;
            resources.ApplyResources(this.richTextBox2, "richTextBox2");
            this.richTextBox2.Name = "richTextBox2";
            this.richTextBox2.KeyDown += new System.Windows.Forms.KeyEventHandler(this.richTextBox2_KeyDown);
            this.richTextBox2.KeyUp += new System.Windows.Forms.KeyEventHandler(this.richTextBox2_KeyUp);
            this.richTextBox2.Leave += new System.EventHandler(this.richTextBox2_Leave);
            // 
            // button1
            // 
            resources.ApplyResources(this.button1, "button1");
            this.button1.Name = "button1";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // panel11
            // 
            resources.ApplyResources(this.panel11, "panel11");
            this.panel11.BackColor = System.Drawing.Color.Transparent;
            this.panel11.Controls.Add(this.panel4);
            this.panel11.Cursor = System.Windows.Forms.Cursors.SizeWE;
            this.panel11.Name = "panel11";
            this.panel11.MouseDown += new System.Windows.Forms.MouseEventHandler(this.panel11_MouseDown);
            this.panel11.MouseMove += new System.Windows.Forms.MouseEventHandler(this.panel11_MouseMove);
            this.panel11.Move += new System.EventHandler(this.panel11_Move);
            // 
            // panel4
            // 
            resources.ApplyResources(this.panel4, "panel4");
            this.panel4.BackColor = System.Drawing.SystemColors.ControlLight;
            this.panel4.Name = "panel4";
            this.panel4.MouseDown += new System.Windows.Forms.MouseEventHandler(this.panel11_MouseDown);
            this.panel4.MouseMove += new System.Windows.Forms.MouseEventHandler(this.panel11_MouseMove);
            // 
            // contextMenuStrip1FRIEND
            // 
            this.contextMenuStrip1FRIEND.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem1,
            this.перепискаToolStripMenuItem});
            this.contextMenuStrip1FRIEND.Name = "contextMenuStrip1";
            this.contextMenuStrip1FRIEND.ShowImageMargin = false;
            resources.ApplyResources(this.contextMenuStrip1FRIEND, "contextMenuStrip1FRIEND");
            // 
            // toolStripMenuItem1
            // 
            this.toolStripMenuItem1.Name = "toolStripMenuItem1";
            resources.ApplyResources(this.toolStripMenuItem1, "toolStripMenuItem1");
            this.toolStripMenuItem1.Click += new System.EventHandler(this.toolStripMenuItem1_Click);
            // 
            // перепискаToolStripMenuItem
            // 
            this.перепискаToolStripMenuItem.Name = "перепискаToolStripMenuItem";
            resources.ApplyResources(this.перепискаToolStripMenuItem, "перепискаToolStripMenuItem");
            this.перепискаToolStripMenuItem.Click += new System.EventHandler(this.перепискаToolStripMenuItem_Click);
            // 
            // contextMenuStrip2CONFER
            // 
            this.contextMenuStrip2CONFER.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem2,
            this.toolStripMenuItem9});
            this.contextMenuStrip2CONFER.Name = "contextMenuStrip1";
            this.contextMenuStrip2CONFER.ShowImageMargin = false;
            resources.ApplyResources(this.contextMenuStrip2CONFER, "contextMenuStrip2CONFER");
            // 
            // toolStripMenuItem2
            // 
            this.toolStripMenuItem2.Name = "toolStripMenuItem2";
            resources.ApplyResources(this.toolStripMenuItem2, "toolStripMenuItem2");
            this.toolStripMenuItem2.Click += new System.EventHandler(this.toolStripMenuItem2_Click);
            // 
            // toolStripMenuItem9
            // 
            this.toolStripMenuItem9.Name = "toolStripMenuItem9";
            resources.ApplyResources(this.toolStripMenuItem9, "toolStripMenuItem9");
            this.toolStripMenuItem9.Click += new System.EventHandler(this.toolStripMenuItem9_Click);
            // 
            // contextMenuStrip3USERS
            // 
            this.contextMenuStrip3USERS.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem11,
            this.toolStripMenuItem13});
            this.contextMenuStrip3USERS.Name = "contextMenuStrip1";
            this.contextMenuStrip3USERS.ShowImageMargin = false;
            resources.ApplyResources(this.contextMenuStrip3USERS, "contextMenuStrip3USERS");
            // 
            // toolStripMenuItem11
            // 
            this.toolStripMenuItem11.Name = "toolStripMenuItem11";
            resources.ApplyResources(this.toolStripMenuItem11, "toolStripMenuItem11");
            this.toolStripMenuItem11.Click += new System.EventHandler(this.toolStripMenuItem11_Click);
            // 
            // toolStripMenuItem13
            // 
            this.toolStripMenuItem13.Name = "toolStripMenuItem13";
            resources.ApplyResources(this.toolStripMenuItem13, "toolStripMenuItem13");
            this.toolStripMenuItem13.Click += new System.EventHandler(this.toolStripMenuItem13_Click);
            // 
            // tabPage4
            // 
            resources.ApplyResources(this.tabPage4, "tabPage4");
            this.tabPage4.Name = "tabPage4";
            this.tabPage4.UseVisualStyleBackColor = true;
            // 
            // tabPage3
            // 
            resources.ApplyResources(this.tabPage3, "tabPage3");
            this.tabPage3.Name = "tabPage3";
            this.tabPage3.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            this.tabPage2.BackColor = System.Drawing.Color.Transparent;
            resources.ApplyResources(this.tabPage2, "tabPage2");
            this.tabPage2.Name = "tabPage2";
            // 
            // tabPage1
            // 
            resources.ApplyResources(this.tabPage1, "tabPage1");
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Controls.Add(this.tabPage3);
            this.tabControl1.Controls.Add(this.tabPage4);
            resources.ApplyResources(this.tabControl1, "tabControl1");
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.SelectedIndexChanged += new System.EventHandler(this.tabControl1_SelectedIndexChanged);
            // 
            // Form1
            // 
            resources.ApplyResources(this, "$this");
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.DarkCyan;
            this.Controls.Add(this.panel11);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.menuStrip1);
            this.Name = "Form1";
            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.panel1.ResumeLayout(false);
            this.panel3.ResumeLayout(false);
            this.panel3.PerformLayout();
            this.panel2.ResumeLayout(false);
            this.panel7.ResumeLayout(false);
            this.panel11.ResumeLayout(false);
            this.contextMenuStrip1FRIEND.ResumeLayout(false);
            this.contextMenuStrip2CONFER.ResumeLayout(false);
            this.contextMenuStrip3USERS.ResumeLayout(false);
            this.tabControl1.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Panel panel11;
        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem4;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem5;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem6;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem7;
        private System.Windows.Forms.Button button9;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;
        public System.Windows.Forms.ContextMenuStrip contextMenuStrip1FRIEND;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem1;
        private System.Windows.Forms.ToolStripMenuItem перепискаToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem аккаунтToolStripMenuItem;
        public System.Windows.Forms.Panel panel7;
        private System.Windows.Forms.RichTextBox richTextBox2;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Panel panel3;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.Panel panel4;
        public System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Panel panel5;
        public System.Windows.Forms.ContextMenuStrip contextMenuStrip2CONFER;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem2;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem9;
        public System.Windows.Forms.ContextMenuStrip contextMenuStrip3USERS;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem11;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem13;
        public System.Windows.Forms.Panel panel6;
        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.TabPage tabPage3;
        private System.Windows.Forms.TabPage tabPage4;
    }
}


Form2.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Net;
using System.Net.Sockets;

namespace chat_client
{
    public partial class Form2 : Form{
        public bool aut;
        private Socket sock;
        string[] commands, answers;
        string key;
        public Form2(string Title, string label1, string label2, string[] commands, string[] answers, string key)
        {
            InitializeComponent();
            setTitle(Title);
            setLabel1(label1);
            setLabel2(label2);
            aut = false;
            sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            Central.connect(sock);
            this.commands = commands;
            this.answers = answers;
            this.key = key;
        }

        private void button1_Click(object sender, EventArgs e){
            Central.write(commands[0], sock);
            Central.write(getParam1(), sock);
            Central.write(getParam2(), sock);
            Central.write(key, sock);
            string res = Central.read(sock);
            if (res == answers[0]){
                sock.Close();
                aut = true;
                this.Close();
            } else MessageBox.Show(Central.read(sock), "Message from server.");
        }
        private void button2_Click(object sender, EventArgs e){
            if (getParam1() == ""){
                MessageBox.Show("User cannot have empty login.", "Warning.");
                return;
            }
            Central.write(commands[1], sock);
            Central.write(getParam1(), sock);
            Central.write(getParam2(), sock);
            string res = Central.read(sock);
            if (res == answers[1]) MessageBox.Show(Central.read(sock), "Message from server.");
            else MessageBox.Show("user with login: \' " + getParam1() + " \' registrated.", "Message from server.");
        }
        public string getParam1() { return textBox1.Text; }
        public string getParam2() { return textBox2.Text; }

        public void setTitle(string s) { this.Text = s; }
        public void setLabel1(string s) { label1.Text = s; }
        public void setLabel2(string s) { label2.Text = s; }
    }
}


Form2.Designer.cs

namespace chat_client
{
    partial class Form2
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.button1 = new System.Windows.Forms.Button();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.button2 = new System.Windows.Forms.Button();
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
            this.button1.Location = new System.Drawing.Point(23, 119);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(192, 27);
            this.button1.TabIndex = 0;
            this.button1.Text = "authorize";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(23, 32);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(192, 20);
            this.textBox1.TabIndex = 1;
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(23, 81);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(192, 20);
            this.textBox2.TabIndex = 2;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(20, 16);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(33, 13);
            this.label1.TabIndex = 3;
            this.label1.Text = "Login";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(20, 65);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(53, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Password";
            // 
            // button2
            // 
            this.button2.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
            this.button2.Location = new System.Drawing.Point(23, 152);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(192, 27);
            this.button2.TabIndex = 5;
            this.button2.Text = "register";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // panel1
            // 
            this.panel1.Anchor = System.Windows.Forms.AnchorStyles.None;
            this.panel1.Controls.Add(this.label1);
            this.panel1.Controls.Add(this.button2);
            this.panel1.Controls.Add(this.button1);
            this.panel1.Controls.Add(this.label2);
            this.panel1.Controls.Add(this.textBox1);
            this.panel1.Controls.Add(this.textBox2);
            this.panel1.Location = new System.Drawing.Point(167, 77);
            this.panel1.MaximumSize = new System.Drawing.Size(235, 201);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(235, 201);
            this.panel1.TabIndex = 6;
            // 
            // Form2
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.DarkCyan;
            this.ClientSize = new System.Drawing.Size(568, 355);
            this.Controls.Add(this.panel1);
            this.MinimumSize = new System.Drawing.Size(251, 239);
            this.Name = "Form2";
            this.Text = "chat";
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.TextBox textBox2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.Panel panel1;
    }
}


Form3.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Form3 : Form
    {
        public Form3(Control first, Control second){
            InitializeComponent();
            panel1.Controls.Add(first);
            if ((Label)second != null)
            {
                second.MaximumSize = new Size(this.Size.Width, 0);
                this.AutoSize = second.AutoSize;
            }
            panel2.Controls.Add(second);
        }
    }
}


Form3.Designer.cs

namespace chat_client
{
    partial class Form3
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel2 = new System.Windows.Forms.Panel();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.Dock = System.Windows.Forms.DockStyle.Top;
            this.panel1.Location = new System.Drawing.Point(0, 0);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(362, 58);
            this.panel1.TabIndex = 0;
            // 
            // panel2
            // 
            this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
            this.panel2.Location = new System.Drawing.Point(0, 58);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(362, 338);
            this.panel2.TabIndex = 1;
            // 
            // Form3
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.DarkCyan;
            this.ClientSize = new System.Drawing.Size(362, 396);
            this.Controls.Add(this.panel2);
            this.Controls.Add(this.panel1);
            this.Name = "Form3";
            this.Text = "Info";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;
    }
}


ItemList_with_Button_more.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class ItemList_with_Button_more : UserControl
    {
        private method load_more_to_this;
        public ItemList_with_Button_more(method load_more_to_this, DockStyle dockStyle, DockStyle Button_more_dockStyle){
            InitializeComponent();
            more = new Button_more(new method(this.more_Click));
            more.Dock = Button_more_dockStyle;
            this.Dock = dockStyle;
            this.Controls.Add(more);
            this.load_more_to_this = load_more_to_this;
        }
        //очищает компонент от когтроллов, и добавляет свой Button_more
        public void Clear(){
            this.Controls.Clear();
            this.Controls.Add(more);
        }
        public int get_n_visible_children() {
            int res = 0;
            foreach (Control obj in Controls) {
                if (obj.Visible) res++;
            }
            return res;
        }
        private void more_Click(object sender, EventArgs e) {
            load_more_to_this(this, e);
        }
    }
}


ItemList_with_Button_more.Designer.cs

namespace chat_client
{
    partial class ItemList_with_Button_more
    {
        /// <summary> 
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором компонентов

        /// <summary> 
        /// Обязательный метод для поддержки конструктора - не изменяйте 
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            // 
            // ItemList_with_Button_more
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoScroll = true;
            this.BackColor = System.Drawing.Color.Transparent;
            this.Name = "ItemList_with_Button_more";
            this.Size = new System.Drawing.Size(160, 163);
            this.ResumeLayout(false);

        }

        #endregion
        Button_more more;
    }
}


Menager_for_conferens.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Menager_for_conference : UserControl
    {
        public Menager_for_conference(User u, Conference c)
        {
            InitializeComponent();
        }

        private void button2_Click(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {

        }

        private void button9_Click(object sender, EventArgs e)
        {

        }

        private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
        {

        }
    }
}

Menager_for_conferens.Designer.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Menager_for_conference : UserControl
    {
        public Menager_for_conference(User u, Conference c)
        {
            InitializeComponent();
        }

        private void button2_Click(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {

        }

        private void button9_Click(object sender, EventArgs e)
        {

        }

        private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
        {

        }
    }
}


Message.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class Message : UserControl
    {
        public string message_ID;
        private Control oldParent;
        private EventHandler Message_SizeChanged_Listener;
        public void init(string message_ID, string time, string message, User messager)
        {
            InitializeComponent();
            this.Size = new Size(40, 32);
            //this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
            //| System.Windows.Forms.AnchorStyles.Left)
            //| System.Windows.Forms.AnchorStyles.Right)));
            this.oldParent = null;
            this.Dock = DockStyle.Bottom;
            this.time.Text = time;
            this.messageText.Text = message;
            panel1.Controls.Add(messager);
            this.Name = message_ID;
            this.message_ID = message_ID;
            this.SizeChanged += (Message_SizeChanged_Listener = new EventHandler(this.Message_SizeChanged));
        }
        public Message(string message_ID, string time, string message, User messager)
        {
            init(message_ID, time, message, messager);
        }

        private void Parent_SizeChanged(object sender, EventArgs e)
        {
            this.MaximumSize = new Size(this.Parent.Size.Width, 0);
        }

        private void Message_ParentChanged(object sender, EventArgs e)
        {
            if (oldParent != null) oldParent.SizeChanged -= Parent_SizeChanged;
            oldParent = this.Parent;
            if (this.Parent != null) this.Parent.SizeChanged += Parent_SizeChanged;
            this.MaximumSize = new Size(this.Parent.Size.Width, 0);
        }

        private void Message_SizeChanged(object sender, EventArgs e)
        {
            this.SizeChanged -= Message_SizeChanged_Listener;
            this.messageText.MaximumSize = new Size(this.MaximumSize.Width, 0);
            //panel2.Size = new Size(this.Size.Width, this.messageText.Location.Y + this.messageText.Size.Height);
            panel1.Size = new Size(this.Size.Width, this.panel2.Location.Y + this.messageText.Location.Y + this.messageText.Size.Height);
            this.Size = new Size(this.Size.Width, panel1.Size.Height + 2);
            this.SizeChanged += Message_SizeChanged_Listener;
            messageText.MaximumSize = new Size(panel2.Size.Width, panel2.MaximumSize.Height);
        }
    }
}

Message.Designer.cs

namespace chat_client
{
    partial class Message
    {
        /// <summary> 
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором компонентов

        /// <summary> 
        /// Обязательный метод для поддержки конструктора - не изменяйте 
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel2 = new System.Windows.Forms.Panel();
            this.messageText = new System.Windows.Forms.Label();
            this.time = new System.Windows.Forms.Label();
            this.panel1.SuspendLayout();
            this.panel2.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.BackColor = System.Drawing.SystemColors.ControlLight;
            this.panel1.Controls.Add(this.panel2);
            this.panel1.Location = new System.Drawing.Point(0, 1);
            this.panel1.MinimumSize = new System.Drawing.Size(40, 30);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(40, 30);
            this.panel1.TabIndex = 0;
            // 
            // panel2
            // 
            this.panel2.AutoSize = true;
            this.panel2.Controls.Add(this.messageText);
            this.panel2.Controls.Add(this.time);
            this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
            this.panel2.Location = new System.Drawing.Point(0, 0);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(40, 30);
            this.panel2.TabIndex = 4;
            // 
            // messageText
            // 
            this.messageText.AutoSize = true;
            this.messageText.Location = new System.Drawing.Point(0, 13);
            this.messageText.Name = "messageText";
            this.messageText.Size = new System.Drawing.Size(31, 13);
            this.messageText.TabIndex = 6;
            this.messageText.Text = "сооб";
            // 
            // time
            // 
            this.time.AutoSize = true;
            this.time.Dock = System.Windows.Forms.DockStyle.Top;
            this.time.ForeColor = System.Drawing.SystemColors.GrayText;
            this.time.Location = new System.Drawing.Point(0, 0);
            this.time.Name = "time";
            this.time.Size = new System.Drawing.Size(39, 13);
            this.time.TabIndex = 5;
            this.time.Text = "время";
            // 
            // Message
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.Transparent;
            this.Controls.Add(this.panel1);
            this.MinimumSize = new System.Drawing.Size(40, 32);
            this.Name = "Message";
            this.Size = new System.Drawing.Size(43, 34);
            this.ParentChanged += new System.EventHandler(this.Message_ParentChanged);
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.panel2.ResumeLayout(false);
            this.panel2.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        public System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.Label messageText;
        public System.Windows.Forms.Label time;


    }
}


User.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace chat_client
{
    public partial class User : UserControl
    {
        public static User getUser(string login){
            return User_fields.getUser_fields(login).getUser();
        }
        private User_fields fields;

        public bool Unread{
            get {
                if (panel1.BackColor == SystemColors.ControlLight) return false;
                else return true;
            }
            set {
                if (value) panel1.BackColor = SystemColors.ControlDark;
                else panel1.BackColor = SystemColors.ControlLight;
            }
        }
        public bool Online
        {
            get
            {
                return this.online.Visible;
            }
            set
            {
                this.online.Visible = value;
            }
        }
        
        public User(string id, string name, ContextMenuStrip contextMenuStrip){
            InitializeComponent();
            this.Dock = DockStyle.Top;
            this.fields = User_fields.getUser_fields(id, name);
            this.ContextMenuStrip = contextMenuStrip;
            this.Unread = this.fields.Unread;
            this.Online = this.fields.Online;
            this.Name = this.fields.Name;
            this.name.Text = this.fields.Name;
            this.fields.UnreadChanged.Add(new method_empty(this.UnreadChanged));
            this.fields.Last_tickChanged.Add(new method_empty(this.Last_tickChanged));
            this.fields.OnlineChanged.Add(new method_empty(this.OnlineChanged));
        }
        public User(User_fields fields, ContextMenuStrip contextMenuStrip)
        {
            InitializeComponent();
            this.Dock = DockStyle.Top;
            this.fields = fields;
            this.ContextMenuStrip = contextMenuStrip;
            this.Unread = this.fields.Unread;
            this.Online = this.fields.Online;
            this.Name = this.fields.Name;
            this.name.Text = this.fields.Name;
            this.fields.UnreadChanged.Add(new method_empty(this.UnreadChanged));
            this.fields.Last_tickChanged.Add(new method_empty(this.Last_tickChanged));
            this.fields.OnlineChanged.Add(new method_empty(this.OnlineChanged));
        }

        public virtual User copy() {
            return new User(fields.ID, fields.Name, this.ContextMenuStrip);
        }

        protected virtual void Contact_Click(object sender, EventArgs e){
            if (this.fields.ID != null) Central.ShowMessages(this.fields);
        }
        public void UnreadChanged()
        {
            this.Unread = fields.Unread;
        }
        public void Last_tickChanged(){
            if (this.Parent != null)
            {

                int n = this.Parent.Controls.Count;
                DateTime this_last_tick = DateTime.Parse(this.fields.Last_tick);
                for (int i = 0; i < n; i++)
                {
                    try
                    {
                        User U = (User)this.Parent.Controls[i];
                        if (DateTime.Parse(U.fields.Last_tick) >= this_last_tick)
                        {
                            this.Parent.Controls.SetChildIndex(this, i);
                            break;
                        }
                    }
                    catch (Exception) { }
                }
            }
        }
        public void OnlineChanged() {
            this.Online = fields.Online;
        }
    }
}

User.Designer.cs

namespace chat_client
{
    partial class User
    {
        /// <summary> 
        /// Требуется переменная конструктора.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Освободить все используемые ресурсы.
        /// </summary>
        /// <param name="disposing">истинно, если управляемый ресурс должен быть удален; иначе ложно.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Код, автоматически созданный конструктором компонентов

        /// <summary> 
        /// Обязательный метод для поддержки конструктора - не изменяйте 
        /// содержимое данного метода при помощи редактора кода.
        /// </summary>
        private void InitializeComponent()
        {
            this.panel1 = new System.Windows.Forms.Panel();
            this.online = new System.Windows.Forms.Label();
            this.name = new System.Windows.Forms.Label();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.BackColor = System.Drawing.SystemColors.ControlLight;
            this.panel1.Controls.Add(this.online);
            this.panel1.Controls.Add(this.name);
            this.panel1.Location = new System.Drawing.Point(0, 1);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(35, 25);
            this.panel1.TabIndex = 0;
            this.panel1.MouseClick += new System.Windows.Forms.MouseEventHandler(this.Contact_Click);
            // 
            // online
            // 
            this.online.AutoSize = true;
            this.online.Dock = System.Windows.Forms.DockStyle.Top;
            this.online.ForeColor = System.Drawing.Color.Gray;
            this.online.Location = new System.Drawing.Point(0, 13);
            this.online.Name = "online";
            this.online.Size = new System.Drawing.Size(35, 13);
            this.online.TabIndex = 1;
            this.online.Text = "online";
            this.online.MouseClick += new System.Windows.Forms.MouseEventHandler(this.Contact_Click);
            // 
            // name
            // 
            this.name.AutoEllipsis = true;
            this.name.AutoSize = true;
            this.name.Dock = System.Windows.Forms.DockStyle.Top;
            this.name.ForeColor = System.Drawing.SystemColors.HotTrack;
            this.name.Location = new System.Drawing.Point(0, 0);
            this.name.Name = "name";
            this.name.Size = new System.Drawing.Size(36, 13);
            this.name.TabIndex = 0;
            this.name.Text = "логин";
            this.name.MouseClick += new System.Windows.Forms.MouseEventHandler(this.Contact_Click);
            // 
            // User
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.Transparent;
            this.Controls.Add(this.panel1);
            this.Name = "User";
            this.Size = new System.Drawing.Size(35, 27);
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Label name;
        private System.Windows.Forms.Label online;
    }
}


User_fields.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System.Windows.Forms;

namespace chat_client
{
    delegate void User_fields_delegate(User_fields sender);
    delegate void for_setUserOnline(bool ch);
    public class User_fields
    {
        public static Dictionary<string, User_fields> Users;//name, user
        public static User_fields getUser_fields(string name){
            if (Users.ContainsKey(name)) return Users[name];
            int k = (int)Central.key.get_friend_id;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write(name, Central.socks[k]);
            User_fields res = null;
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                string id = Central.read(Central.socks[k]);
                if (id == "0") res = new User_fields(name);
                else res = new User_fields(id, name);
                Users[name] = res;
                Central.insert_friend(res);
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
            return res;
        }
        public static User_fields getUser_fields(string id, string name)
        {
            if (Users.ContainsKey(name)){
                Users[name].ID = id;
                if (id == null && Central.friends.Controls.ContainsKey(name)) Central.friends.Controls.RemoveByKey(name);
                else Central.insert_friend(Users[name]);
                return Users[name];
            }
            User_fields res = (Users[name] = new User_fields(id, name));
            Central.insert_friend(res);
            return res;
        }

        private bool unread, online;
        private string last_tick, name, id;
        public ItemList_with_Button_more messages;
        public List<method_empty> UnreadChanged, OnlineChanged, Last_tickChanged;

        private User_fields(string id, string name) : this(name)
        {
            ID = id;
        }
        private User_fields(string name)
        {
            UnreadChanged = new List<method_empty>();
            OnlineChanged = new List<method_empty>();
            Last_tickChanged = new List<method_empty>();
            this.name = name;

            int k = (int)Central.key.get_last_user_tick;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            DateTime now;
            Central.start_dialog(k);
            Central.write(Central.log, Central.socks[k]);
            Central.stop_dialog(k);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                now = DateTime.Parse(Central.read(Central.socks[k]));
                online_checker(now, Central.still_online);
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
        }
        public User getUser() {
            if (Central.friends.Controls.ContainsKey(this.Name)) return new User(this, Central.Chat.contextMenuStrip1FRIEND);
            else return new User(this, Central.Chat.contextMenuStrip3USERS);
        }

        public void unread_and_last_tick_checker()
        {
            if (this.ID == null || this.ID == "0") return;
            int k = (int)Central.key.geter_freand_unread_last_tick;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write(this.ID, Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                this.Unread = Convert.ToBoolean(Convert.ToInt16(Central.read(Central.socks[k])));
                this.Last_tick = Central.read(Central.socks[k]);
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }
        public void online_checker(DateTime now, int still_online)
        {
            int k = (int)Central.key.get_last_user_tick;
            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            //for_setUserOnline set_userOnline = new for_setUserOnline(this.setUserOnline);
            Central.start_dialog(k);
            Central.write(this.name, Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                if (DateTime.Parse(Central.read(Central.socks[k])) > now.AddMinutes(still_online)) this.Online = false;
                else this.Online = true;
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }

        private void run_listeners(List<method_empty> methodsList)
        {
            int n = methodsList.Count;
            for (int i = 0; i < n; i++)
            {
                try { methodsList[i](); }
                catch (Exception e)
                {
                    MessageBox.Show(e.ToString(), "Error.");
                }
            }
        }

        public bool Unread
        {
            get { return unread; }
            set
            {
                if (value != unread)
                {
                    unread = value;
                    run_listeners(UnreadChanged);
                }
            }
        }
        public bool Online
        {
            get { return online; }
            set
            {
                if (value != online)
                {
                    online = value;
                    run_listeners(OnlineChanged);
                }
            }
        }
        public string Last_tick
        {
            get { return last_tick; }
            set
            {
                if (value != last_tick)
                {
                    last_tick = value;
                    run_listeners(Last_tickChanged);
                }
            }
        }

        public string Name
        {
            get { return name; }
        }
        public string ID
        {
            get { return id; }
            private set {
                if (id != value)
                {
                    id = value;
                    if (value != null)
                    {
                        messages = new ItemList_with_Button_more(new method(this.load_more_messages), DockStyle.Fill, DockStyle.Top);
                        messages.AutoScroll = true;
                        unread_and_last_tick_checker();
                    } else messages = null;
                }
            }
        }

        //для вызова из двугого потока с использованием инвок
        public void insert_message(object message_ID, object time, object message, object login) {
            insert_message((string)message_ID, (string)time, (string)message, (string)login);
        }
        public void insert_message(object m) { insert_message((Message)m); }
        //при использовании этой перегрузки метода не приходится создавать лишних слушателей событий
        public void insert_message(string message_ID, string time, string message, string login) {
            if (!messages.Controls.ContainsKey(message_ID)) insert_message(new Message((string)message_ID, (string)time, (string)message, User.getUser((string)login)));
        }
        public void insert_message(Message m)
        {
            if (!messages.Controls.ContainsKey(m.Name))
            {
                messages.Controls.Add(m);
                if (messages.Controls.Count > 2)
                {
                    DateTime time_of_message = new DateTime();
                    time_of_message = DateTime.Parse(m.time.Text);
                    foreach (object obj_ in messages.Controls)
                    {
                        try
                        {
                            Message obj = (Message)obj_;
                            if (DateTime.Parse(obj.time.Text) >= time_of_message)
                            {
                                messages.Controls.SetChildIndex(m, messages.Controls.IndexOf(obj));
                                if (messages.Controls.IndexOf(m) == messages.Controls.Count - 1) messages.VerticalScroll.Value = messages.VerticalScroll.Maximum;
                                break;
                            }
                        }
                        catch (Exception) { }
                    }
                }
            }
        }
        private void load_more_messages(object sender, EventArgs e){
            load_more_messages();
        }
        public void load_more_messages()
        {
            int k = (int)Central.key.geter_n_m_messages_p;

            if (Central.socks[k] == null) Central.set_right(k);
            if (Central.socks[k] == null) Central.Fatal_Error();
            Central.start_dialog(k);
            Central.write((messages.Controls.Count - 1).ToString(), Central.socks[k]);
            Central.write((messages.Controls.Count - 1 + 10).ToString(), Central.socks[k]);
            Central.write(ID, Central.socks[k]);
            if (Central.read(Central.socks[k]) == Central.answers[0])
            {
                int n = Convert.ToInt32(Central.read(Central.socks[k]));
                Message[] messages_ = new Message[n];
                User messager;
                string message_ID, message, login, time;
                for (int i = 0; i < n; i++)
                {
                    message_ID = Central.read(Central.socks[k]);
                    message = Central.read(Central.socks[k]);
                    login = Central.read(Central.socks[k]);
                    time = Central.read(Central.socks[k]);
                    messager = User.getUser(login);
                    this.insert_message(new Message(message_ID, time, message, messager));
                }
            }
            else
            {
                MessageBox.Show(Central.read(Central.socks[k]), "Message from server.");
                Central.socks[k].Close();
                Central.set_right(k);
            }
            Central.stop_dialog(k);
        }
    }
}

Waiter.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace chat_client
{
    delegate object method_obj1(object obj1);

    class Waiter{
        public object res;
        public Waiter(ref UInt64 first, ref UInt64 second, method_obj1 m, object obj1){
            while (first != second) { System.Threading.Thread.Sleep(5); }
            ++first;
            res = m(obj1);
            second++;
        }
        public Waiter(ref UInt64 first, ref UInt64 second, method_empty m){
            while (first != second) { System.Threading.Thread.Sleep(5); }
            ++first;
            m();
            second++;
        }
    }
}
